<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tell me this isn't a SPA</title>
  </head>
  <style>
    body {
      position: absolute; /* only need to do this because of the navbar and footer */
      overflow: hidden; /* since footer is absolute, we will need a scrollbar inside */
      width: 100%; /* take up the entire screen */
      height: 100%; /* ditto */
      margin: 0; /* no margins to avoid blank area around the edges */
      padding: 0; /* no need */
      display: flex; /* flexbox makes life easy */
      flex-direction: column; /* vertical layout */
      justify-content: center; /* center everything */
      align-items: center; /* ditto */
      text-align: center; /* ditto */
    } /* this is the container that will hold everything */

    .dark {
      background-color: #222; /* DARK theme (1) */
      color: #fff; /* white text */
    }
    .dark a {
      color: #88f; /* purple links */
    } /* theme 1 (DARK) */

    .purple {
      background-color: #88f; /* PURPLE theme (2) */
      color: #ff0; /* yellow text */
    }
    .purple a {
      color: #292; /* green links */
    } /* theme 2 (PURPLE) */

    .green {
      background-color: #0f0; /* GREEN theme (3) */
      color: #911; /* red text */
    }
    .green a {
      color: #999; /* gray links */
    } /* theme 3 (GREEN) */

    nav,
    footer {
      width: 100%;
      position: absolute;
      background-color: #222; /* keep nav and footer dark */
    } /* take up whole screen at the top and bottom */

    nav {
      top: 0;
    } /* nav on top */

    ul {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      list-style: none;
    } /* make the nav into a horizontal, evenly spaced list */

    main {
      width: 100%; /* take up the whole screen */
      overflow-y: auto; /* scrollable */
      margin-top: 3rem; /* leave room for the navbar */
      margin-bottom: 1rem; /* leave room for the footer */
    }

    img {
      aspect-ratio: 1/1; /* square-ish */
      object-fit: contain; /* scale to fit */
      width: 100%; /* take up the whole area if you can */
      max-height: 50vh; /* but not too big */
    }

    footer {
      bottom: 0; /* starting at bottom */
    }
  </style>
  <body class="dark">
    <nav>
      <ul>
        <li>
          <a href="/" class="Link">Home</a>
        </li>
        <li>
          <a href="/about" class="Link">About</a>
        </li>
        <li>
          <a href="/products" class="Link">Products</a>
        </li>
        <li>
          <a href="/cart" class="Link">Cart</a>
          <span id="cart-count"></span>
          <span id="cart-total"></span>
        </li>
        <li>
          <input
            aria-label="Search"
            type="text"
            placeholder="Search"
            id="search"
          />
        </li>
        <li>
          <button id="toggleTheme">Toggle Theme</button>
        </li>
      </ul>
    </nav>
    <main class="main"></main>
    <footer>
      <a href="http://jazzypants.dev"> Â© 2023 Jovial Penguin, LLC.</a>
    </footer>
    <script defer>
      // Global variables are starting to get ... intense...
      const main = document.querySelector(".main")
      // Get the main element, which will be used to render the dynamic content
      const links = document.querySelectorAll(".Link")
      // Instead of targeting every <a> tag, we only target internal navigation links
      let products = {}
      // An initial empty object for us to cache our products in
      const themeCheck = localStorage.getItem("theme")
      // Get the theme from localStorage
      const toggleTheme = document.querySelector("#toggleTheme")
      // Get the toggleTheme button
      const cartCount = document.querySelector("#cart-count")
      // Get the cart count element
      const cartAmount = document.querySelector("#cart-total")
      // Get the cart total element
      const search = document.querySelector("#search")

      // Bring in the cart and initiate the DOM with the current cart state
      const cart = JSON.parse(localStorage.getItem("cart")) || {}
      // Get the cart from localStorage, or set it to an empty object if it doesn't exist
      cartCount.innerText = Object.keys(cart).length
      // Set the cart count to the number of items in the cart
      cartAmount.innerText =
        "$" +
        Object.values(cart)
          .map((item) => item.product.price * item.quantity)
          .reduce((a, b) => a + b, 0)
          .toFixed(2)
      // Update the cart amount

      // Set the theme
      themeCheck // If there is a theme in localStorage
        ? (document.body.className = themeCheck) // Set the theme on the body element
        : (document.body.className = "dark") // Otherwise, default to dark

      // This function will run every time the user clicks the toggleTheme button and change the theme.
      toggleTheme.addEventListener("click", () => {
        // Check current theme
        const currentTheme = localStorage.getItem("theme") || "dark"
        // Get the current theme from localStorage, or set it to dark if it doesn't exist.
        const newTheme =
          currentTheme === "dark" // if the current theme is dark
            ? "purple" // set the new theme to purple
            : currentTheme === "purple" // but, if the current theme is purple
            ? "green" // set the new theme to green
            : "dark" // otherwise, set the new theme to dark
        localStorage.setItem("theme", newTheme) // Save the new theme to localStorage
        document.body.className = newTheme // Set the new theme on the body element
      })

      // "Database" of products
      const db = async () => {
        // This has to be async because we're using fetch
        const response = await fetch("/db.json") // Get the db.json file
        const data = await response.json() // Parse the JSON
        console.log("Initial DB fetch")
        return data // Return the data
      }

      const getProducts = async () => {
        // This has to be async because we're using fetch
        if (products.length > 0) {
          console.log("Products have been cached")
          return products // If we've already fetched the products, return them
        }
        console.log("Products are being fetched")
        const data = await db() // Get the data from the db
        products = data.products // Set the empty object to the products in the db
        return products // Return the products
      }

      // Almost all of our final components
      const Home = () => {
        console.log("Home component is rendering")
        document.title = "Home" // Set the page title
        render(`
            <p>This is a totally real shop! See! That's a picture! Of a shop! Totally
          open.</p>
          <img src="/diana.avif" alt="Check us out" />
            `)
      } // Hmm, this looks familiar.

      const About = () => {
        console.log("About component is rendering")
        document.title = "About"
        render(`
            <h1>About</h1>
          <p>
            This is a totally real shop that sells totally real products. It's not a
            demonstration of how client-side routing works. Noo! It's just a
            shop.
          </p>
            `)
      } // It's a functional component!

      const ProductComponent = (product) => {
        console.log("A product is rendering")
        return `
            <div class="product">
              <a href=/product/${product.id} class="Link">
                <img src="${product.image}" alt="${product.name}" />
              <h2>${product.name}</h2>
              </a>
              <p>${product.description}</p>
              <p>$${product.price}</p>
              <button class="add-to-cart" id="${product.id}">Add to cart</button>
            </div>
            `
      } // Oh look, we're passing props now.

      const ProductsPage = async () => {
        console.log("Products component is rendering")
        document.title = "Products"
        const products = await getProducts() // Get the products
        const productsHTML = Object.values(products)
          .map((product) => ProductComponent(product))
          .join("") // Map over the products and render each one
        render(productsHTML) // Render the products
        buttonFinderAdd() // Find the add to cart buttons
      }

      const ProductPage = async (id) => {
        console.log(
          `The ProductPage component is rendering product with ID: ${id}`
        )
        await getProducts() // Get the products
        const product = products.find((product) => product.id === Number(id)) // Find the product that matches the id
        if (!product) {
          return Nope(id)
        }
        document.title = product.name // Set the page title to the product name
        search.value = product.name // Set the search input value to the product name
        product ? render(ProductComponent(product)) : Nope(id) // If we find a product, render it. If not, render the 404 page.
        buttonFinderAdd() // Find the add to cart buttons
      }

      // Create the cart component
      const Cart = async () => {
        console.log("Cart Component is rendering")
        const cart = JSON.parse(localStorage.getItem("cart")) || {}
        // Get the cart from localStorage, or set it to an empty object if it doesn't exist.
        const products = await getProducts() // Get the products
        if (Object.keys(cart).length === 0) {
          // If the cart is empty, render a message saying so.
          render(`
          <h1>Cart</h1>
          <p>Your cart is empty. Go buy one of our two amazing items!</p>
          `)
        } else {
          // If the cart isn't empty, render the cart items.
          const cartItems = Object.keys(cart).map((id) => {
            const product = products.find(
              (product) => product.id === Number(id)
            )
            return `
            <div class="cart-item">
              <img src="${product.image}" alt="${product.name}" />
              <h2>${product.name}</h2>
              <p>$${product.price}</p>
              <p>Quantity: ${cart[id].quantity}</p>
              <button class="remove-from-cart" id="${product.id}">Remove from cart</button>
            </div>
            `
          })
          render(`
          <h1>Cart</h1>
          ${cartItems.join("")}
          `)
          buttonFinderRemove()
        }
      }

      const Nope = (id) => {
        console.log(`404 Component just rendered on ${location.pathname}`)
        console.log(`ID detected: ${!!id}`) // The double bang is just a fancy way of converting the id to a boolean. If there's an id, it'll be true. If there isn't, it'll be false.
        if (id) {
          render(
            `<h1>404</h1><h2>Sorry buddy, but I don't think we have a product with id #${id}!</h2>`
          )
        } else {
          render(`<div>
              <h1>404</h1>
              <h2>Huh, you're at ${location.pathname}, but you really shouldn't be... ðŸ¤” </h2>
            </div>`)
        }
      } // Only on v1 of this project, and I already have 2 404 pages... I think that's a good sign?

      const Routes = [
        { path: "/", component: Home },
        { path: "/about", component: About },
        { path: "/products", component: ProductsPage },
        { path: "/product", component: ProductPage },
        { path: "/cart", component: Cart },
      ]

      // METHOD ONE (BIG ROUTER)
      const Router = (potentialRoute) => {
        const dynamicRoute = "product" // Define a dynamic route
        const searchRoute = "products" // Define a search route
        const searchParams = new URLSearchParams(location.search) // Get the search params from the URL
        if (
          // DYNAMIC ROUTE LOGIC
          potentialRoute.split("/")[1] === dynamicRoute && // We're turning the path into an array by splitting it every time we see a slash. Then we're checking to see if the second item in the array is the same as the dynamicRoute global variable we set at the top of the file.
          potentialRoute.split("/")[2]
        ) {
          console.log("Dynamic route detected")
          const id = potentialRoute.split("/")[2] // If it is, we're getting the id from the third item in the array. This limits us to only having one dynamic route and only at that point in the array, but we're just showing one way to do it here. This would much more capable and flexible if we were to use regex, but I refuse.
          return ProductPage(id)
        } else if (
          // SEARCH ROUTE LOGIC
          potentialRoute.split("/")[1] === searchRoute &&
          searchParams.has("name")
        ) {
          console.log("Search route detected")
          const searchValue = searchParams.get("name")
          search.value = searchValue
          return searchHandler()
        } else {
          // STATIC ROUTE LOGIC
          console.log("Static route detected")
          const route = Routes.find(
            (route) => route.path === potentialRoute // We're finding the route that matches the path in the address bar.
          )
          route ? route.component() : Nope()
        }
      }

      // Our reactive search.

      search.addEventListener("input", searchHandler) // Add an event listener to the search input element we defined with our global variables.

      async function searchHandler() {
        // This is the function that will run every time the user types in that input.
        const searchValue = search.value // Because our search input is a global variable, we can just grab the value from it.
        console.log(`Searching for ${searchValue}`)
        products = await getProducts() // Get the products
        const filteredProducts = products.filter((product) => {
          return product.name.toLowerCase().includes(searchValue.toLowerCase()) // We're converting both the product name and the search value to lowercase so that we can search for "shirt" and "Shirt" and "SHIRT" and "sHiRt" and it will still work.
        })
        if (filteredProducts.length === 0) {
          render(`<h1>Products</h1><p>No products found!</p>`) // A third 404 page! I'm on a roll!
        } else {
          const productsHTML = filteredProducts.map(ProductComponent).join("")
          render(`<h1>Products</h1>${productsHTML}`)
          buttonFinderAdd()
        }
      } // both methods share this function

      // METHOD TWO (EVERY ROUTE IS A SEARCH ROUTE)

      async function urlSearchHandler() {
        const searchParams = new URLSearchParams(window.location.search)
        // Create a new URLSearchParams object from the search query in the URL.
        const searchValue = searchParams.get("search")
        // Get the value of the search query.
        search.value = searchValue
        // Set the value of the search input to the search query.
        products = await getProducts()
        // Get the products from the database.

        const filteredProducts = products.filter((product) => {
          return product.name.toLowerCase().includes(searchValue.toLowerCase())
          // Filter the products to only include the ones that match the search query.
        })

        if (filteredProducts.length === 0) {
          render(`<h1>Products</h1><p>No products found!</p>`)
          // If there are no products, Render a message saying so.
        } else {
          const productsHTML = filteredProducts.map(ProductComponent).join("") // If there are products, we're mapping over them and rendering them.
          render(`<h1>Products</h1>${productsHTML}`)
          buttonFinderAdd()
        }
      }

      function render(component) {
        console.log(`The render function just ran with ${component}`)
        // Since we only have one dynamic element on the page and very content in common between pages,
        main.innerHTML = component
        // We can just replace the entire innerHTML of the main element
        linkFinder()
        // And then run the linkFinder function to add event listeners to our links
      }

      // This function will run every time the user clicks the "Add to cart" button.
      function addToCart(product) {
        console.log(`Added ${product.name} to cart`)
        if (cart[product.id]) {
          // If the product is already in the cart, increment the quantity.
          cart[product.id].quantity++
        } else {
          // If the product isn't in the cart, add the product and a quantity property to the cart.
          cart[product.id] = {
            quantity: 1,
            product,
          }
        }
        localStorage.setItem("cart", JSON.stringify(cart))
        // Set the cart in localStorage to the updated cart.
        alert(`${product.name} added to cart!`)
        // Alert the user that the product was added to the cart.
        cartCount.innerText = Object.keys(cart).length
        // Update the cart count.
        cartAmount.innerText =
          "$" +
          Object.values(cart).reduce((acc, item) => {
            return acc + item.product.price * item.quantity
          }, 0) // Update the cart amount.
      }

      // This function will run every time the user clicks the "Remove from cart" button.
      function removeFromCart(product) {
        console.log(`Removed ${product.name} from cart`)
        // Decrement the quantity.
        cart[product.id].quantity--
        if (cart[product.id].quantity === 0) {
          // If the quantity is 0, remove the product from the cart.
          delete cart[product.id]
        }
        localStorage.setItem("cart", JSON.stringify(cart)) // Set the cart in localStorage to the updated cart.
        alert(`${product.name} removed from cart!`) // Alert the user that the product was removed from the cart.
        Cart() // Re-render the cart.
        cartCount.innerText = Object.keys(cart).length // Update the cart count.
        cartAmount.innerText =
          "$" +
          Object.values(cart)
            .map((item) => item.product.price * item.quantity)
            .reduce((a, b) => a + b, 0)
            .toFixed(2) // Update the cart amount.
      }

      // This function is for our product pages so users can add items to the cart.
      function buttonFinderAdd() {
        document.querySelectorAll(".add-to-cart").forEach((button) => {
          // Get all the buttons with the class "add-to-cart"
          if (button.alreadyAdded) return
          button.alreadyAdded = true
          // Check if the button has already been added
          button.addEventListener("click", (e) => {
            // Add an event listener to each button if not
            const id = e.target.id
            // Get the id of the product from the button
            const product = products.find(
              (product) => product.id === Number(id)
            )
            // Find the product in the products array
            addToCart(product)
            // Add the product to the cart
          })
        })
      }

      // This function is for our cart page so users can remove items from the cart.
      function buttonFinderRemove() {
        document.querySelectorAll(".remove-from-cart").forEach((button) => {
          // Get all the buttons with the class "remove-from-cart"
          if (button.alreadyAdded) return
          button.alreadyAdded = true
          // Check if the button has already been added
          button.addEventListener("click", (e) => {
            // Add an event listener to each button if not
            const id = e.target.id
            // Get the id of the product from the button
            const product = products.find(
              (product) => product.id === Number(id)
            )
            // Find the product in the products array
            removeFromCart(product)
            // Remove the product from the cart
          })
        })
      }

      // Essential to any routed SPA, our linkFinder function will run every time we render a component. It will find all the links in the component, and add event listeners to them. When the user clicks a link, it will prevent the default behavior of the link (which is to navigate to a new page), and instead run the Router function with the path of the link as the argument.
      function linkFinder() {
        const links = document.querySelectorAll(".Link") // instead of targeting every anchor tag, we only target the ones meant for navigating around our app.
        links.forEach((link) => {
          if (link.alreadyAdded) return // This is so that we don't add multiple event listeners to the same link.
          link.alreadyAdded = true
          console.log(`Changing link behavior of ${link}`)
          // Target each link that we have marked with the Link class,
          link.addEventListener("click", (e) => {
            // add a click event listener
            e.preventDefault() // prevent the default behavior of the anchor tag (opening a new page)
            const linkPath = link.getAttribute("href") // get the href attribute of the link (the path)
            history.pushState(null, null, linkPath) // push the link's path to the history object
            Router(linkPath) // call the Router function with the link's path
          }) // Ta-da! We have a SPA! Oh, wait. We need to call the Router function once to render the initial page.
        })
      }

      // We check for search params, then run the urlSearchHandler function if there are any.
      let urlParams = new URLSearchParams(window.location.search)
      if (urlParams.has("search")) {
        urlSearchHandler()
      } else {
        Router(location.pathname)
      }

      console.log("Hello from chapter 14.")

      // Now, we need to add a listener for the popstate event.

      window.addEventListener("load", () => {
        window.addEventListener("popstate", () => {
          Router(location.pathname)
        })
      })
    </script>
  </body>
</html>

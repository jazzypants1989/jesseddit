---
title: "The Navigation API"
nextLink: "./5-view-transitions-api"
githubLink: true
---

import CodeBlock from "../../../components/CodeBlock.astro"
import IFrame from "../../../components/IFrame.astro"
import Demo from "../../../components/Demo.astro"
import InfoBox from "../../../components/InfoBox.astro"
import SimpleRouter from "../../../components/demos/navigation/SimpleRouter.mdx"
import PreventDefault from "../../../components/demos/navigation/PreventDefault.mdx"
import FavoriteState from "../../../components/demos/navigation/FavoriteState.mdx"
import IFrameRecursion from "../../../components/demos/navigation/IFrameRecursion.mdx"
import LoadingAndError from "../../../components/demos/navigation/ErrorAndLoading.mdx"
import KittenGallery from "../../../components/demos/navigation/KittenGallery.mdx"
export const demoURL = "/demos/into-the-future/4-navigation-api/"

## Introduction

As we learned in my [Brief History of Client-Side Routing](/articles/client-side-routing/2-a-brief-history-of-client-side-routing), we have come a long way from the days of the hash-based router. [Our router](/articles/client-side-routing/11-router-link-and-routes) has been built leveraging [the History API](/articles/client-side-routing/7-the-history-api), and it has served us well. But, in order to use it, we have to make sure that we put our special `Link` class on every single internal link. And, we had to do all kinds of gymnastics just to make sure that [popstate](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event) events were handled correctly.

Wouldn't it be great if we could just put down a single event listener and let the browser do the work for us? Well, hooray! The [Navigation API](https://github.com/WICG/navigation-api) is here to do just that. It also smooths out a few additional rough edges that we didn't encounter in our app. Let's take a look at how it works.

<InfoBox warning>
As of the time of this article's writing, the Navigation API is currently [only available in Google Chrome, Microsoft Edge, and Opera browsers](https://caniuse.com/mdn-api_navigation). Here's to hoping that it will be available in all browsers soon!
</InfoBox>

## The `navigation` Object

As we learned, all of these web API's sit on the `window` object. The navigation API is no different, so we can call it by just typing `navigation` as long as we know our code will run on the browser. It has a few events, but the most important of all is the titular `navigate` event. This event is fired whenever **any** navigation occurs. Let's see how we can use it.

<SimpleRouter />

Around 20 lines of actual code and one event listener later, and we have a fully functional client-side router. It even handles [popstate events](https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event)! So, let's explore how this works and see what else we need to think about.

## The `navigate` Event

As soon as the page loads, I log the `currentEntry` property to the console. I also log the `NavigateEvent` interface and the `entries` method of the `navigation` object on each navigation. If you open the [developer tools](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools), you can take a look at them. Respectively, they represent where we are in the browser's history, where we are trying to go, and all the pages that have been visited in the current session.

Using these three, we can intercept the navigation and do whatever we want. The `key` property of each entry is what we can use to go to a specific page in the history. It's a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) that is generated by the browser for each instance of each page in the user's history. The `id` property is similar, but [it's a little more likely to change](https://github.com/WICG/navigation-api#the-current-entry) so usually it's best to use the `key` property. The `navigation.entries` method is our way of seeing the current state of the history stack. Using the `key` property, we can go back to any page in this stack.

Finally, the [NavigateEvent has a lot of properties](https://github.com/WICG/navigation-api#navigation-monitoring-and-interception), but the one you'll be checking most often is `destination`-- specifically, `destination.url`. This is the URL that we are trying to load into the browser. With just that and a few other important things, you have all the information you need to hand things off to an internal router. Usually, the best way to do this is with the `intercept` method on the event. This method takes an object with a `handler` property. This handler is the function that we can use to route each navigation event.

## Intercepting Navigation

As you can see, if you [open the demo in another window](/demos/into-the-future/4-navigation-api/1) and click the external links, they still work as the intercept method doesn't prevent the default behavior on its own. While you usually want to allow your users to leave your site, there are times when you don't-- like when a user is in the middle of a [form submission.](https://github.com/whatwg/html/issues/6600) Let's see how we can do that.

<PreventDefault />

Click around to see the differences between the two modes. If you have anything in the search fields while in preventDefault mode, you will see a prompt when you try to leave. Also, when you search, notice how the formData is automatically included any time it is a part of a navigation event. This is one of the key things to keep in mind when deciding whether or not to intercept each navigation. 

There are a few other times when you might not want to intercept the navigation and just let the browser do its thing. Here's [an example function provided by the Chrome team](https://developer.chrome.com/docs/web-platform/navigation-api/) for how you might want to check.

<CodeBlock noButtons>
```js
function shouldNotIntercept(navigationEvent) {
  return (
    !navigationEvent.canIntercept ||
    // If this is just a hashChange,
    // just let the browser handle scrolling to the content.
    navigationEvent.hashChange ||
    // If this is a download,
    // let the browser perform the download.
    navigationEvent.downloadRequest ||
    // If this is a form submission,
    // let that go to the server.
    navigationEvent.formData
  );
}
```
</CodeBlock>

The canIntercept property is a boolean that tells us whether or not we're even allowed to intercept the navigation. As you saw, any "cross-origin or cross-document" (a different website or completely replacing the current document) navigation cannot be intercepted. We check for this to avoid unnecessary errors. The others are just situations where the browser can usually handle things better than we can.

## Navigation State

One feature of the History API that I elected not to use in my original implementation was the ability to set the state object. This is a way to store data inside of the browser's history. While having an in-memory cache that persists between history entries seems like something too good to deny, there are a few reasons why I didn't use it.

The history state is notoriously fickle, and even something as simple as a single hashChange event can cause it all to be lost. And, if you want events to be exactly like they were at one point in history, you have to be extremely careful about how you set the state. Usually, you end up storing your desired state in a separate variable or a web storage API anyways to protect it. In this next demo, we will explore some of these issues to see how the Navigation API improves upon them.

<FavoriteState />

This demo starts out using the History API. As you can see, it mostly works well enough. The problems only start to arise when you do something like selecting a state and then clicking on the hash links. As you can see, each hashChange counts as a new entry with completely separate state from the previous entry, but hash links are usually on the same page so this is not what we want.

Also, although we can go back to a selected state if we favorite it, it is completely out of context from the decisions made before and after that particular state was selected. We have no access into the history stack other than blindly traversing by a number of entries, so we can't see exactly **when** the user wants to go back to. This is where the Navigation API comes in.

Now, switch over to the Navigation API. When you mark a state as your favorite, we are saving the key of that specific entry. Then, we are using the "traverseTo" method to go to that specific entry. Because the Navigation API gives us access to the entire history stack of our current session, we can go back to any specific state in time. When you go to the favorite state, notice how your forwards button on your browser has been filled with all of the entries after you favorited the state. And, it's even smart enough to know if it should make a new entry or replace the current entry based on the URL!

## Navigation Types and iFrames

If you check the console, you can see that each navigation event is categorized into one of four navigationType's: `traverse`, `push`, `replace`, and `reload`. In the History API code, we had to imperatively create a new history entry with each navigation. The Navigation API automatically detects this ([although this can be overridden in certain situations.](https://github.com/WICG/navigation-api#the-current-entry)) In summary, a navigation to the same URL is automatically categorized as a `replace` navigation, a navigation to a new URL is automatically categorized as a `push` navigation, and a navigation to a specific entry in the history stack is categorized as a `traverse` navigation. You can guess what `reload` means.

One issue with the History API is that a session's history is shared across all the websites visited. Unfortunately, they did not have the foresight when designing it to consider multiple iFrames on a single page. This next demo is the same as the previous one, but with an iframe of itself inside itself. This isn't the best representation of the issues as it is the same origin, but it is enough to demonstrate part of the problem.

<IFrameRecursion />

Notice how all your interactions between both iframes get put on the same history stack? This is because the history stack is global to the whole browser. With the Navigation API, each iFrame gets a stack of its own that the app developer can inspect at their leisure. Unlike the History API where we can only go backwards and forwards an arbitrary number of entries across one stack, each of these stacks can be independepently traversed. Generally, I haven't had much of an issue with this, but it is a [recurring](https://github.com/WICG/webcomponents/issues/184) [complaint](https://github.com/dvoytenko/web-history-api/blob/master/problem.md) of more experienced developers than me so I felt the need to mention it.

One easy way to see the improvement is to notice how the navigation stack doesn't grow when clicking on the same URL when using the app in navigation API mode. This is because it is logging those entries with `replace` navigation types. We use the `updateCurrentEntry` method to update the state of the current entry in these cases. You will rarely need to do this, but it is useful in situations when you still need to update the state. Multi-step forms with sensitive information come to mind.

## Loading and Error States

One issue that has plagued developers when working with the History API is that all changes to the history stack are synchronous. However, since most apps don't have all of their data loaded into the browser at once, you need to prepare for what happens in between the time the user clicks a link and the time the data is loaded. Not only do you need to know when the data is loaded, but you must know that it has been loaded correctly. And, if a user changes their mind in the middle of stuff happening, you need to be able to cancel the loading process or else you end up with a lot of unnecessary data.

While the [`AbortController` interface](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) has been introduced to help with this, it's not always easy to plug it into your existing routing solution. Luckily, the NavigateEvent interface has a `signal` property which is an `AbortSignal` that you can use to cancel the loading process. We can use this to track whether or not the user has changed their mind while data is loading.

Although it is still synchronous by default, most of the traversal methods provided by the Navigation API return a pair of promises that you can use to track the navigation-- `committed` and `finished`. The `committed` promise resolves when the navigation has been initiated and the URL changes in the address bar. The `finished` promise resolves when the navigation has been completed and the page has been rendered. Between the two, you can track the loading state of your app. Let's see how this works in practice.

<LoadingAndError />

So, as usual, we're using the intercept method to handle the navigation. Our handler function just delays everything by three seconds to simulate a slow loading process. You can do whatever you want in the handler function.

I included the "navigate" button to show that doing something extra on top of the core loading strategy is really easy. I gave this a different loading spinner which I explicitly put between the `committed` and `finished` promises. These promises are handy for when the timing of your loading and cleanup operations are important, but you can take advantage of this transition without explicitly naming them. Take a look at the main intercept handler function for an example of that.

The navigate button employs a try/catch block. Deferring to the global abort signal is managed in the error handling here with the line `if (e instanceof DOMException) return`. A DOMException is rarely thrown, so we can safely assume it will be caught by our global abort signal. If you look at the console.log's, you can see that an abort signal is fired every time that you click on a link while the `finished` promise is still resolving. This shows that we are not loading any unnecessary pages as we reject any extra, unresolved promises.

## Converting our App

Now that we have explored some simple demonstrations of these core concepts, let's put them to work in our application. Unlike the previous chapters in this series, this time we will actually be removing files thanks to the Navigation API. Specifically, we'll be saying goodbye to `Link.js` because we no longer need to specifically target internal links.

As we've seen, all I really need to do is add this event listener and we're done.

<CodeBlock noButtons>
```js
navigation.addEventListener("navigate", (event) =>
  event.intercept({
    async handler() {
      const url = event.destination.url
      const newUrl = new URL(url)
      Router(newUrl.pathname)
    },
  })
) 

```
</CodeBlock>

But, that wouldn't be a very exciting tutorial if that was all we did. And, we're not really taking full advantage of the asychronous nature of the Navigation API this way. So, let's add some more functionality to our app.

As it is, even though we're now fetching our products from a remote API, we aren't presenting any loading state to the user. And, when users click on multiple things, we're loading everything even though we only show the last thing that was clicked. All of this can be easily fixed by adding a few things to our central event listener. Here's the updated version:

<CodeBlock>
```js
import { Route } from "./Routes.js"
import { searchHandler, search } from "../features/search.js"
export const main = document.querySelector(".main")

export default function Router(navigateEvent) {
  if (shouldNotIntercept(navigateEvent)) return

  // Get URL
  const url = navigateEvent ? navigateEvent.destination.url : location.href
  const newURL = new URL(url)
  const path = newURL.pathname
  const searchParams = new URLSearchParams(newURL.search)
  const searchValue = searchParams.get("search")

  if (navigateEvent && path === location.pathname) {
    navigateEvent.preventDefault()
    main.scrollTo({
      top: 0,
      behavior: "smooth",
    })
    return
  }

  // Start Spinner
  const spinner = createSpinner()
  const mainHTML = main.innerHTML
  checkAndReplaceHTML(mainHTML, spinner, 300)

  // Check for search
  if (searchValue) {
    Route(path)
    search.value = searchValue
    return searchHandler()
  }

  // Route
  navigateEvent
    ? navigateEvent.intercept({
        async handler() {
          navigateEvent.signal.onabort = () => {
            console.log("aborted")
            main.innerHTML = mainHTML
          }
          try {
            await Route(path)
          } catch (error) {
            console.log("error", error)
            main.innerHTML = Nope("error", error)
          }
        },
      })
    : Route(path)
}

navigation.addEventListener("navigate", Router)

function checkAndReplaceHTML(mainHTML, spinner, time) {
  setTimeout(() => {
    if (mainHTML === main.innerHTML) {
      main.innerHTML = spinner.outerHTML
    }
  }, time)
}

function shouldNotIntercept(navigateEvent) {
  if (!navigateEvent) return
  return (
    !navigateEvent.canIntercept ||
    navigateEvent.hashChange ||
    navigateEvent.downloadRequest ||
    navigateEvent.formData
  )
}

function createSpinner() {
  const spinner = document.createElement("div")
  // Nothing crazy, you can check the CSS for this
  spinner.classList.add("spinner")
  return spinner
}
```
</CodeBlock>

So, instead of creating a separate function for our event listener, we simply have it call our central Router. In the router, we check to see if it is the first load by checking for the presence of a NavigateEvent. We just need to know where to get our URL, because the rest of the logic is the same from there.

Instead of an entirely separate function to check for the presence of a search query, we just check for it in the Router. If it is present, we call the search handler and return. Otherwise, we continue to our main logic.

Like I said, you don't need to explicitly name the `{committed, finished}` promise pair to take advantage of asychronous loading. Here, I am simply replacing the main content with a spinner as part of the loading process. However, it would be jarring to see this spinner on every navigation.

So, I created a function to determine how long the main content has been loading by simply checking to see if the HTML has changed. If it has been loading for more than 300ms, then we replace the main content with the spinner. Otherwise, we just leave it alone. This was inspired by [this tweet conversation](https://twitter.com/kentcdodds/status/1645796797435215875?s=20).

The last thing we need to do is add a little bit of error handling. If the user clicks on a link while the previous page is still loading, we want to abort the previous page. For this, I opted to use the `onabort` property of the included AbortSignal. If the signal is aborted, we simply replace the main content with the original HTML. If it is a real error, we call the 404 page and embed the error message.

As for our dynamic routes and 404 handling, I moved all of that to our `Route` function because it makes sense to keep all of this logic near our source of truth: the Routes array. This is what it looks like now:

<CodeBlock>
```js
import Nope from "../pages/Nope.js"

const Routes = [
  { path: "/", component: "Home" },
  { path: "/about", component: "About" },
  { path: "/products", component: "Products" },
  { path: "/product", component: "ProductPage", dynamic: true },
  { path: "/cart", component: "Cart" },
  { path: "/checkout", component: "Checkout" },
]

export async function Route(path) {
  const route = Routes.find(
    (route) => route.path.split("/")[1] === path.split("/")[1]
  )
  if (!route) return Nope()

  const component = await import(`../pages/${route.component}.js`)
  if (route.dynamic) {
    const id = path.split("/")[path.split("/").length - 1]
    return component.default(id)
  }
  return component.default()
}
```
</CodeBlock>

## Conclusion

The Navigation API has been carefully crafted to build on top of the foundation laid by the History API. As I repeatedly demonstrated, all that you have to do is place a single event listener, and all of the previous tricks still work. This was intentional to support gradual adoption.

While the most attractive feature may be that everything is routed through a central event listener, that initial appeal is hiding a whole host of other quality-of-life improvements. Being able to detect the presence of formData, download requests, and hash changes is a huge win, and the ability to inspect each history entry is a game-changer. It is much easier to create conditional routing logic when all of the information is in one place.

Although this is only available in Chromium-based browsers, I think you can see that I'm really excited about the potential of this API-- especially when combined with the topic of our next chapter: the View Transitions API. As a parting note, here is one more demo that I couldn't find an excuse to include in the article. 

This cat picture gallery is inspired by the idea of intercepting routes-- a feature recently introduced in Next.JS. While I understand the concept, I don't personally think it leads to the best UX when a user doesn't know what to expect from a specific URL.

So, in my version, the only way to see a full-screen cat picture on load with the base URL is if you refresh the page while the picture is active, or leave then navigate back to it in the back/forwards cache. Alternatively, you can share the link to a full-screen picture by pressing the button that gives you a URL with a search query.

See you next time!

<KittenGallery />
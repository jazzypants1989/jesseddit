---
title: "React Server Components"
nextLink: "./2-flight-request"
---

## Introduction

In December 2020, the React team released a [“special Holiday Update”](https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) which included an hour long talk by Dan Abramov and Lauren Tan as well as an accompanying demo where people could try out an exciting new technology called “React Server Components”. It's been a long journey from that point, and the underlying API's have changed a bit since then, but they are now reaching a point of maturity. So, let's take a close look at the libraries necessary to implement RSC's, and let's see if we can try to build our own simple framework.

## History of SSR in React
>So, you could— in theory— render the markup on the server, and then attach all the event handlers and instantiate all the backing views on the client. Two completely separate machines!
--[Jordan Walke, JSConf 2013](https://www.youtube.com/watch?v=GW0rj4sNH2w)

While it has had the ability to pre-render applications on the server [since its very inception](https://www.phpied.com/remarkable-react/), there has been a key distinction that many miss in how server-side rendering works in React. Traditionally, API's like `renderToString` only produce a visual representation of the current state of the application. Essentially, it converts the requested page into a string of HTML. However, this must be fully re-constructed into a virtual DOM in the user's browser so that things that depend on JavaScript like event listeners will work correctly. 

To reap the SEO and initial load benefits that _SSR_ provides, the entire application must be rendered twice. First, when the string representation is created on the server, and then again when it is hydrated on the client with a call to the `render` method on the root element. This issue is sometimes known as the ["Double Data Problem"](https://www.babbel.com/en/magazine/exploring-web-rendering-isomorphic-javascript-hydration). 

And, you don't want to dump all that work every time the user clicks a link. Even though you server-rendered the first page, you need to ensure that the user has the improved navigation experience of a Single Page Application. So, you also have to load even more JavaScript for a client-side router. 

Beyond that superficial additional overhead, there are [a multitude of new things to worry about](https://dev.to/this-is-learning/why-efficient-hydration-in-javascript-frameworks-is-so-challenging-1ca3) as the developer must now make decisions about when and how to "hydrate" the HTML. While client-rendered SPA's may not be fully search engine optimized, at least those developers never have to worry about problems like the ["Uncanny Valley"](https://dev.to/this-is-learning/resumability-wtf-2gcm)-- a term that describes the hopefully brief period where things like buttons don't work because they haven't been hydrated yet. 

To maximize your [core web vitals](https://web.dev/vitals/), you have to be extremely careful about how much JavaScript you load initially. Things like [React.Suspense and React.lazy](https://web.dev/code-splitting-suspense/) help with this, but often developers use these tools to an extreme. This can lead to applications that are not much more than an empty shell full of loading spinners hiding client-side data-fetching waterfalls.

While [a whole host of techniques](https://www.patterns.dev/posts/rendering-patterns) have been developed by the community for making this process as efficient as possible, the React team has been developing a first-party solution for these problems for quite some time now. Although this series of articles will be mostly focusing on React Server Components which are internally codenamed _Flight_ by the React team, _RSC_'s are completely dependent on their earlier research into HTTP streaming codenamed _Fizz_. The original release of streaming SSR was with [React 16.0 in 2017](https://medium.com/hackernoon/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67). This stuff takes time!

## What Are React Server Components?
>In a lot of ways, server components is "Suspense for Data Fetching". That's what that is. We're not calling it that anymore, but that is our first-class, like, this is the solution we think for the best way to compose data requirements into your app.
--[Andrew Clark, React Roundtable: Server Components, Suspense, and Actions](https://www.youtube.com/watch?v=g5BGoLyGjY0)

While there are [obvious benefits to streaming by itself](https://medium.com/airbnb-engineering/improving-performance-with-http-streaming-ba9e72c66408), the React team have gone even further. Essentially, [React Server Components](https://vercel.com/blog/understanding-react-server-components) allow you to completely pre-render certain static portions of your UI on the server into a serialized representation. However, unlike traditional _SSR_, this is not a string of HTML, and none of the JavaScript necessary for building those components ever needs to be sent to the client.

[This can be extremely powerful](https://vercel.com/blog/how-react-18-improves-application-performance) when you consider how this now allows you to use the server to do things like [make calls to your database](https://www.mux.com/blog/what-are-react-server-components) inside of your component. Instead of trying to figure out how to bounce back authentication requests using things like `useEffect` calls while trying to hide secrets in the browser, server components allow you to simply use the classic unidirectional flow that React has always provided. You don't have to worry about your secrets leaking because that code never runs in the browser. The data that is streamed is [fully serialized into a special data format colloquially known as the _RSC Payload_](https://demystifying-rsc.vercel.app/).

However, we are no longer limited to purely static portions of websites, as the React team have recently unveiled [server actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions). This is a form of [Remote Procedure Call](https://en.wikipedia.org/wiki/Remote_procedure_call). We'll explore how they work in closer detail in later chapters.

## The Current RSC Landscape
>From the React perspective, when we put on our React hats (even people who work at Vercel), their goal is to prove out the paradigm, figure out how the pieces should fit, and figure out how to make React better... On the one hand, I get a lot of criticisms of Vercel. On the other hand, it just gets under my skin when people say that Vercel tells the React team what to do. When... actually, it's more complicated. The reality is that Vercel has invested years into building out our vision.
--Dan Abramov, ["React Core Panel" by Joe Savona, Ricky Hanlon, Dan Abramov, & Michael Jackson at #RemixConf 2023 💿
](https://www.youtube.com/watch?v=WiEtFPYGgbM)

At the time of this writing, the [Next.js `app` router](https://nextjs.org/blog/next-13) is around eleven months old. Developers have been able to use server actions in Next.js for around a third of that. [One intrepid developer has even built dev tools for it](https://www.alvar.dev/blog/creating-devtools-for-react-server-components). So, why haven't any other frameworks fully adopted React Server Components to the same extent yet? 

The obvious answer is that this stuff is just really complicated, it's not the easiest thing to implement, and the API's are rapidly changing. While several of the members of the React core team now work at Vercel, none of this code is hidden away. Everything is open-source.

Having the ability to rapidly prototype these features in a production framework like Next.js gives the React team the ability to throw things at the wall and see what sticks. It's easy to imagine how things should work, but reality can be brutal when that imagination meets production applications with hundreds of external dependencies. So, while some have complained about this being some sort of inside advantage given to Vercel, it doesn't change the exigency of this partnership in guiding the development of React Server Components.

And, it doesn't necessarily pay to be an early adopter. The Next.js team has received many complaints about the performance of the development server of the `app` router (although this has admittedly improved recently). Additionally, the Hydrogen team at Shopify were the first to adopt React Server Components, but [they soon abandoned them](https://shopify.engineering/remix-joins-shopify) with Shopify's purchase of Remix. Chief among their complaints was the idea that the strict yet nebulous separation between the server and the client made things too complicated for their engineers. 

The React team used this experience to guide changes to some key implementation details. For instance, [in the original RFC](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md), server and client components were resolved using a special filename syntax of `.server.jsx` and `.client.jsx` respectively. Now, this has been changed to [`use client` directives](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md) at the top of files for client components and [`use server` directives for server actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions) that can be more granular. Ironically, [Ryan Florence has recently announced](https://syntax.fm/show/649/supper-club-ryan-florence-of-remix#t=44:18) that Remix 3.0 will be based on React Server Components, but to be fair the Shopify team have always said they still believed in the technology.

## Why Am I Doing This?
>A lot of people think it's about data loading. That's just a minor piece of it... Remix is all about levers-- on letting you move code to the server and keep it out of the browser so that you have better performance... And, RSC is just another one of those levers that lets us move even more stuff over to the server that you don't actually need. You're making a network call for JSON anyway. Like, just get the elements! You don't need the templates in the browser.
--Ryan Florence, [Syntax 649: Supper Club × Ryan Florence of Remix](https://syntax.fm/show/649/supper-club-ryan-florence-of-remix)

Recently, I created a [series of silly demos](https://github.com/jazzypants1989/rsc-from-scratch) in response to the challenges presented at the end of Dan Abramov's incredible article, [RSC From Scratch. Part 1: Server Components](https://github.com/reactwg/server-components/discussions/5). I wanted to complete as many of them as possible without using `react-server-dom-webpack` to help show the basic ideas behind how things like client components work. Eventually, I ended up using _RSDW_ to help me with streaming capabilities due to my inexperience in that area, but I have to recommend [JSer's similar article on the subject](https://jser.dev/react/2023/04/10/guess-rsc) for going where I would not.

In the end, there were several different versions of the app. The [ones that used react-server-dom-webpack](https://github.com/jazzypants1989/rsc-from-scratch/tree/main/8%20-%20Streaming) show how to simply implement streaming server components, but we didn't create any module maps so we couldn't include client components. The [other final versions](https://github.com/jazzypants1989/rsc-from-scratch/tree/main/9%20-%20Client%20Components) showed how to implement a quick runtime check using our experimental Node loader and RSC server that Dan Abramov included in the demo to do a transformation of each client component so that it could be registered in the browser by our client JavaScript.

However, there were many issues with my naive implementations which would make them worthless in any kind of production environment. Most of these were due to my stubborn refusal to use the official libraries provided by React properly. So, after finishing that series, I decided to take a closer look at how one would go about creating a real RSC framework. After two months of research & delirium, I think I'm starting to understand.

## Conclusion

In this series of articles, I will attempt to document my understanding of how React Server Components work by methodically expounding on each detail piece by piece. We will explore `react-server-dom-webpack`, but we will quickly see it simply provides useful environmental wrappers around the core libraries `react-server` and `react-client`. So, we will fully unwrap each of those libraries as well as we eventually compose an intricate web of connections between them. 

After exploring those three libraries, I'll briefly talk about the other RSC implementation package `react-server-dom-esm`, as well as the hopefully upcoming `react-server-dom-vite`. Then, we will dive into the ways people have actually been using these libraries. I'll start with some simple examples that can barely be considered frameworks, but we will end with hopefully understanding the way RSC's work in Next.js to a degree.

Finally, we will build a simple framework ourselves. This won't be much more complex than the examples that already exist in the flight demos in the [fixtures folder](https://github.com/facebook/react/tree/main/fixtures) of the official React repository, but we'll put our own spin on it to try to maximize simplicity and ease of understanding. It's all for the sake of education, but after these articles perhaps you will be able to contribute to one of the frameworks that we will cover.

So, I hope you'll join me on this journey. Like I said, we'll start by attemping to understand the code. In the next chapter, we'll begin by diving into each of the core libraries. First, we'll look at `react-server` which is where it all begins with a "Flight Request".
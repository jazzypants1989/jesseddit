---
title: "REJECTZ"
nextLink: "./2-flight-request"
---
import CodeBlock from "../../../components/CodeBlock.astro"

Many people are sick of having to craft their code for working in different runtimes. You can see this in the growing popularity of tools like [Nitro](https://nitro.unjs.io/) and [Hono](https://hono.dev) which pride themselves on allowing you to write your code in one way and have it run anywhere. People don't want to have to worry about changing something as fundamental as how their server sends and receives requests based on where they are hosting their app.

While [_TC39_](https://tc39.es/) has been rapidly improving JavaScript itself, and _WHATWG_ has been fully established as the authority for the browser, server-side code has been a bit of a wild west until recently. Although Node was the only game in town originally, there are now [a wide variety of options](https://en.wikipedia.org/wiki/List_of_server-side_JavaScript_implementations).

Thankfully, a new group named [_WinterCG_] has recently emerged. The Web-interoperable Runtimes Community Group seeks to establish a set of core specifications that each of these runtimes can base themselves around. So, while people had to figure out basic things like streaming through trial and error, this stuff will be carefully formulated in the future. The recent [Web Crypto Streams](https://webcrypto-streams.proposal.wintercg.org/) standard is fully based on the _WHATWG Streams_ standard.


We first check to see if our value is something called a `SuspenseException`. First, let's look at that.

<CodeBlock>
```js
var SuspenseException = new Error("Suspense Exception: This is not a real error! It's an implementation " 
+ 'detail of `use` to interrupt the current render. You must either ' 
+ 'rethrow it immediately, or move the `use` call outside of the ' 
+ '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\n\n' 
+ 'To handle async errors, wrap your component in an error boundary, or ' 
+ "call the promise's `.catch` method and pass the result to `use`");
```
</CodeBlock>

So, as you can see, this is just a weird part of the `use` hook. Let's take a quick look at it.

<CodeBlock>
```js
function use(usable) {
  if (usable !== null && typeof usable === 'object' || typeof usable === 'function') {
    // $FlowFixMe[method-unbinding]
    if (typeof usable.then === 'function') {
      // This is a thenable.
      var thenable = usable; // Track the position of the thenable within this fiber.

      var index = thenableIndexCounter;
      thenableIndexCounter += 1;

      if (thenableState === null) {
        thenableState = createThenableState();
      }

      return trackUsedThenable(thenableState, thenable, index);
    } else if (usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {
      var context = usable;
      return readContext(context);
    }
  }

  {
    if (isClientReference(usable)) {
      error('Cannot use() an already resolved Client Reference.');
    }
  } // eslint-disable-next-line react-internal/safe-string-coercion


  throw new Error('An unsupported type was passed to use(): ' + String(usable));
}
```
</CodeBlock>

<CodeBlock>
```js
function trackUsedThenable(thenableState, thenable, index) {
  var previous = thenableState[index];

  if (previous === undefined) {
    thenableState.push(thenable);
  } else {
    if (previous !== thenable) {
      // Reuse the previous thenable, and drop the new one. We can assume
      // they represent the same value, because components are idempotent.
      // Avoid an unhandled rejection errors for the Promises that we'll
      // intentionally ignore.
      thenable.then(noop, noop);
      thenable = previous;
    }
  } // We use an expando to track the status and result of a thenable so that we
  // can synchronously unwrap the value. Think of this as an extension of the
  // Promise API, or a custom interface that is a superset of Thenable.
  //
  // If the thenable doesn't have a status, set it to "pending" and attach
  // a listener that will update its status and result when it resolves.


  switch (thenable.status) {
    case 'fulfilled':
      {
        var fulfilledValue = thenable.value;
        return fulfilledValue;
      }

    case 'rejected':
      {
        var rejectedError = thenable.reason;
        throw rejectedError;
      }

    default:
      {
        if (typeof thenable.status === 'string') ; else {
          var pendingThenable = thenable;
          pendingThenable.status = 'pending';
          pendingThenable.then(function (fulfilledValue) {
            if (thenable.status === 'pending') {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = 'fulfilled';
              fulfilledThenable.value = fulfilledValue;
            }
          }, function (error) {
            if (thenable.status === 'pending') {
              var rejectedThenable = thenable;
              rejectedThenable.status = 'rejected';
              rejectedThenable.reason = error;
            }
          }); // Check one more time in case the thenable resolved synchronously

          switch (thenable.status) {
            case 'fulfilled':
              {
                var fulfilledThenable = thenable;
                return fulfilledThenable.value;
              }

            case 'rejected':
              {
                var rejectedThenable = thenable;
                throw rejectedThenable.reason;
              }
          }
        } // Suspend.
        //
        // Throwing here is an implementation detail that allows us to unwind the
        // call stack. But we shouldn't allow it to leak into userspace. Throw an
        // opaque placeholder value instead of the actual thenable. If it doesn't
        // get captured by the work loop, log a warning, because that means
        // something in userspace must have caught it.


        suspendedThenable = thenable;
        throw SuspenseException;
      }
  }
} // This is used to track the actual thenable that suspended so it can be
// passed to the rest of the Suspense implementation â€” which, for historical
// reasons, expects to receive a thenable.

var suspendedThenable = null;
function getSuspendedThenable() {
  // This is called right after `use` suspends by throwing an exception. `use`
  // throws an opaque value instead of the thenable itself so that it can't be
  // caught in userspace. Then the work loop accesses the actual thenable using
  // this function.
  if (suspendedThenable === null) {
    throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');
  }

  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}

```
</CodeBlock>
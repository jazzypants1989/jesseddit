---
title: "Flight Request"
nextLink: "./3-flight-response"
---

import CodeBlock from "../../../components/CodeBlock.astro"
import Chunk from "../../../components/demos/rscs/Chunk.mdx"
import RenderToReadableStream from "../../../components/demos/rscs/RenderToReadableStream.mdx"
import CreateRequest from "../../../components/demos/rscs/CreateRequest.mdx"
import CreateTask from "../../../components/demos/rscs/CreateTask.mdx"
import PingTask from "../../../components/demos/rscs/PingTask.mdx"
import StartAndScheduleWork from "../../../components/demos/rscs/StartAndScheduleWork.mdx"
import PerformWork from "../../../components/demos/rscs/PerformWork.mdx"
import RetryTaskTry from "../../../components/demos/rscs/RetryTaskTry.mdx"
import RetryTaskCatch from "../../../components/demos/rscs/RetryTaskCatch.mdx"
import AttemptResolveElement from "../../../components/demos/rscs/AttemptResolveElement.mdx"
import EmitModelChunk from "../../../components/demos/rscs/EmitModelChunk.mdx"
import ResolveModelToJSON from "../../../components/demos/rscs/ResolveModelToJSON.mdx"
import StartFlowing from "../../../components/demos/rscs/StartFlowing.mdx"
import Stream from "../../../components/demos/rscs/Stream.mdx"


## Introduction

Since the dawn of the web, every single interaction has been dictated by a central [_request-response cycle_](https://backend.turing.edu/module2/lessons/how_the_web_works_http). In order to view something on the internet, a client uses a browser to make a _request_. In return, a server processes that _request_ in order to produce the desired _response_ and send it back. The client then consumes that _response_ which can even contain specially encoded methods for the client to _reply_ to the server with a more granular _request_. While the nature of these _requests_ and the size and format of the _responses_ have varied greatly over time, nothing on the internet can be achieved outside of this cycle.

In this chapter, we will begin to explore the way that React uses these concepts to shape the API for React Server Components. To begin, we will demonstrate how to progressively stream a server component to the client with as little code as possible. While the demo will only contain around 50 lines of code between two files, you may be surprised at the complexity hiding beneath as we leverage the libraries that React has provided. 

## `react-server-dom-webpack` and `react-server`

As of the time of this writing, there is currently only one implementation of React Server Components in wide use. This is `react-server-dom-webpack`. To clarify, there is no aspect of RSC's that actually requires webpack. In fact, there is at least one other implementation, `react-server-dom-esm`, that you can use if you build the current experimental versions of React yourself.

The main way in which these two libraries differ is in how they resolve and load modules for client components and server actions. All of the important functionality is actually located in two entirely separate core libraries-- `react-server` and `react-client`. These two core libraries are not actually functional by themselves as they expect to be given configuration files that adapt them to different module-loading environments. This is what the implementation libraries like `react-server-dom-webpack` provide.

This theme of customizing the code for the specific runtime environment goes even deeper than this. One of the first things you will notice when looking at [the files in the repository](https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack/src) is that we have multiple versions of each of the major exports designed for the browser, the edge, and Node respectively. We'll take a closer look at the differences in these later, but first let's get a better idea about how `react-server` and `react-server-dom-webpack` intersect.

The easiest way to see this division of responsibilities is to compare the pre-compiled code for one of the files in `react-server-dom-webpack` to what it looks like afterwards. First, take a quick look at [ReactFlightDOMServerBrowser.js](https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightDOMServerBrowser.js)-- only around 100 lines. But, notice all those imports at the top from files in the `react-server` package? Now, behold the [3,400 line behemoth that file compiles into](https://unpkg.com/browse/react-server-dom-webpack@0.0.0-experimental-dd480ef92-20230822/cjs/react-server-dom-webpack-server.browser.development.js). 

The vast majority of that code came from `react-server`. Like I said, `react-server` and `react-client` contain the core functionality. `react-server-dom-webpack` just provides the configuration files [like this one](https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackReferences.js) that tell React how to do things like resolve and import modules, but the fundamental concepts like streaming will be the same regardless so they are simply imported. Speaking of streaming, let's take a closer look at how that works so we can better understand the code later.

## Web Streams

[Streaming](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API#concepts_and_usage) has been a part of the web since the very beginning. You can see this when an image loads in slowly as the browser renders it bit by bit. The idea behind it is basically just processing something as you receive it instead of loading the entire thing into memory.

While it is fundamentally a pretty simple concept, there is a bit of nuance and history when it comes to working with streams in JavaScript. There are technically two distinct methods of streaming content with JS. [Node Streams](https://nodejs.org/api/stream.html) came first all the way back in [2009](https://medium.com/the-node-js-collection/a-brief-history-of-node-streams-pt-2-bcb6b1fd7468). This was the only way to stream data with JavaScript until WHATWG announced [Web Streams](https://streams.spec.whatwg.org/) in 2014.

While Node streams were revolutionary, they are fundamentally limited in that they cannot run outside of a Node environment (with a few exceptions). So, you can't use them in some other places where you might need JavaScript-- in the browser, for instance. But, because Web Streams are a web standard, you can use them everywhere that you can use JavaScript-- [even in Node](https://nodejs.org/api/webstreams.html). However, they were not fully integrated into browsers until recently, and a lot of the web has already been built on Node Streams.

This is part of the reason for the separate files in `react-server-dom-webpack`. For instance, the Web and Edge versions of  react-server-dom-webpack/server export a function called `renderToReadableStream` whereas the Node version exports a function called `renderToPipeableStream`. As you might have guessed, the previous two leverage Web Streams whereas the latter uses Node Streams. We will cover these in greater depth later, but I wanted to get this distinction out of the way.

## Promises

While this may seem like a random detour, a solid grasp of [how promises work in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) is necessary for us to fully understand how React Server Components work as well. To quote MDN, "A Promise is an object representing the eventual completion or failure of an asynchronous operation... [it's] a proxy for a value not necessarily known when the promise is created." A promise is always in one of three states: _pending_, _fulfilled_, or _rejected_. 

Whether a promise is _fulfilled_ or _rejected_, it becomes _settled_ or _resolved_ once it is no longer _pending_. This can only happen once. Until then, the promise is _unresolved_. The most important thing to understand about promises is that they always possess a `.then` method. This method takes two arguments-- one for the fulfilled case and one for the rejected case. Either way, it returns an entirely new, unresolved promise. Because of this, they can be chained one after the other.

While promises have been in JavaScript since [around 2013](https://web.dev/promises/), several libraries implemented similar functionality beforehand. Thus, there are many objects that exist with a `.then` method that are not technically promises. Generally, while these may have many similarities to actual promises, they may not have all of the same properties. So, they are often called [_thenables_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables) to mark the distinction. Promises were designed to work natively with most _thenables_.

## Chunks and Thenables

_Chunk_ and _Thenable_-- both of these words are used by the React team to define core aspects of the Server Components API. Let's start with _Chunk_. To quote [Thomas Steiner on web.dev](https://web.dev/streams/#chunks), "A chunk is a single piece of data that is written to or read from a stream. It can be of any type; streams can even contain chunks of different types. Most of the time, a chunk will not be the most atomic unit of data for a given stream. For example, a byte stream might contain chunks consisting of 16 KiB Uint8Array units, instead of single bytes."

So, this definition is quite literal when we are talking about RSC's. When we talk about _Chunks_, you should think about small, individual units of work. Later, we will talk about webpack chunks. To distinguish these, note that streaming _RSC Chunks_ have a capital 'C'. To help understand what's happening here, let's take a look at [the code in the `react-server-dom-webpack/server.browser` file that we looked at earlier](https://github.com/vercel/next.js/blob/236075362a1ea368a625e887ef269e8af750fe1c/packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.development.js#L2703) where they define the Chunk class.

<Chunk />

Don't worry if you don't fully get this just yet. The important thing to understand here is that they sub-class the promise prototype and create their own custom `.then` method. So, every single _Chunk_ is a _Thenable_. We're about to go deeper into the code, but this is very important to keep in mind as we go through this.

## `renderToReadableStream`

So, let's go back into `react-server-dom-webpack/server` and begin our journey through the code. We'll explore each function in detail. For now, we'll stick with the browser version since we've already taken a couple looks at that code. 

As I said at the beginning of the chapter, every interaction on the internet starts with a request. To process these requests and respond with a streaming RSC payload in a browser environment, React provides a function called `renderToReadableStream`. Here it is in full:

<RenderToReadableStream />

So, let's start with the two main arguments. We have a `model` and a `webpackMap`. The `model` will typically be the React Element that serves as the root of the application. The `webpackMap` contains the references necessary to import the modules required for the client components and server actions used in the `model`. Along with some options, React uses these arguments to produce a readable stream representation of the application.

The first step is to use the `createRequest` function to create a _Flight Request_ object. Next, we can pass in an [AbortController's](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) so that we can gracefully cancel the readableStream. Finally, we set up the actual stream as a byte stream with [the necessary methods](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#creating_your_own_custom_readable_stream) provided by `react-server`.

The `start` method is only called once at the beginning of the stream, and the `pull` method is called every time the stream reader requests more data. For these methods, React provides the `startWork` and `startFlowing` functions respectively. The `cancel` method appears to be a no-op, but that doesn't seem to matter. Assumedly, this is covered by the `AbortController` mentioned previously.

The `highWatermark` determines when the pull method is called, and I honestly don't know why it is set at 0. I would appreciate any insight in [the comments](https://jessedit.tech/blog/react-server-components#comments). For now, let's take a closer look at the `createRequest` function to see what React is doing to prepare the content to be streamed.


## createRequest

<CreateRequest />

As you can see, every single argument passed into `renderToReadableStream` gets used here. So, this is where all of the important processing happens. The other functions used in `renderToReadableStream` work exactly the same on every single request. `createRequest` is responsible for transforming the `model` and `bundlerConfig` (the root React element and a manifest of the modules needed) into a _Flight Request_ that is serialized and ready to be streamed. So, let's take a look at how it does that.

As you can see, the primary purpose of the `createRequest` function is the production of a monolithic object that keeps track of all the important details of the stream throughout the course of the network request. If you look closely at the code from earlier, you'll see that this request object will be attached to every single _Chunk_ on their `_request` property. In this way, React can gradually update the object and not only track the chunks that it has already serialized, but also which ones it still needs to process by simply checking this property on each chunk.

Although there are quite a few properties on the _Flight Request_ object, they each serve distinct roles in helping React process the stream. We will cover almost all of them in due course. First, let's take a look at what happens after the object is created.

To start things off, the `pendingChunks` property of the request object is iterated from 0 to 1. This is to indicate that the root chunk is being built. Next, we establish the root context and create the root task which is then pushed into the `pingedTasks` queue. To understand the purpose of this and the very nature of a _Task_, let's take a closer look at the `createTask` function and the `pingedTasks` queue.

## createTask and pingTask

<CreateTask />

First, we create an id from the `nextChunkId` property on the request which is a number that started at 0. After this, that number is incremented by one. So, in the case of the `rootTask`, this moves the `nextChunkId` on the _Flight Request_ object from 0 to 1 while assigning the `rootTask` an `id` of 0. That object is also given a status of _PENDING_, the `model` waiting to be resolved, any `context` necessary, a `thenableState` of null, and a `ping` method. This function is important, and we'll see what it does soon. Finally, each task is added to the `abortSet` and returned.

So, it seems that each task is attempting to resolve a `model` into a `Chunk`. Because the `rootTask` is the first task created, it is the only thing in the `pingedTasks` queue. Let's take a look at the `pingTask` function itself which takes the whole request as its first argument, and a single task as the second.

<PingTask />

So, it just pushes the task onto the queue. Then, it runs the `performWork` function as soon as possible if there is only one task in the queue. Also, it checks to see if the `destination` property has changed from `null` to see if it should set a property called `flushScheduled` to `true`.

This seems to be what the `createRequest` function is ultimately attempting to do after setting up the _Flight Request_. It prepares a `rootTask` with a `ping` method so that it can run the `performWork` function. So, let's move into the next part of `renderToReadableStream` to see how the `ping` method is used.

## scheduleWork, startWork, and performWork

Okay, these functions are simple, so we should move through them quickly. First, we have `startWork`. We saw this used earlier as the [`start` method inside `renderToReadableStream`](#renderToreadablestream), and we established that it would only be called once to begin the stream. This is how it works in the browser version.

<StartAndScheduleWork />

<PerformWork />

The code starts and ends by preparing something called a `HooksDispatcher`. Despite common belief otherwise, there are actually [quite a few hooks that you can use in React Server Components](https://unpkg.com/browse/react-server-dom-webpack@0.0.0-experimental-dd480ef92-20230822/cjs/react-server-dom-webpack-server.browser.development.js#L906). In fact, it seems like they are building `useId` and `use` to have very important purposes that we will explore in later articles. For now, just know that this is where they get set up on each request.

The important bit that we'll explore closer is what's happening inside of the `try` block. As you can see, this is where it loops through the `pingedTasks` queue. For each task, it runs the `retryTask` function and passes in the whole `request` as the first argument and the `task` as the second argument. 

Finally, it checks that `destination` property again to see if it is not `null`. If so, it should run a function called `flushCompletedChunks`. We haven't actually seen any functions that manipulate that property yet though, so it should still be `null`. In fact, our `rootTask` should still be _PENDING_ as well. Let's take a closer look at `retryTask` to see how that will change.

## retryTask 

This is our first complex function, so I'm going to break it up into two pieces. It's all based around a `try`/`catch` sequence, but this is a little different from normal error handling. So, let's start with the set-up and the `try` block first.

<RetryTaskTry />

Our `rootTask` is still _PENDING_ so it passes the early return. The `context` gets set, and then we move straight into the `try` block. [We already established that the `model` is usually a React Element](#rendertoreadablestream). If so, it must have a [$$typeof property](https://overreacted.io/why-do-react-elements-have-typeof-property/) that React uses to make sure that it can be processed properly. Any time we see these _REACT_ALL_CAPITAL_ variables, [it's usually a reference to a symbol like this](https://unpkg.com/browse/react-server-dom-webpack@0.0.0-experimental-dd480ef92-20230822/cjs/react-server-dom-webpack-server.browser.development.js#L590).

<CodeBlock noButtons>
```js
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
```
</CodeBlock>

If the `model` in the `rootTask` of the _Flight Request_ has this property, this means that this will be a _React Server Component_, and we enter the next section of code. Here, we see them attempt to store the `thenableState` property from the task, but it hasn't been set yet in the case of the `rootTask`. We'll see that happen later. 

First, the `attemptResolveElement` function is run in order to process the component. If it succeeds, the `thenableState` is reset to `null` and the `while` loop is entered. This loop will continue to run recursively as long as the `value` it returns is a React Element-- meaning it also needs to be processed with `attemptResolveElement`.

Note that the `try` block ends with the `emitModelChunk` function. This is where the `model` is actually serialized into a _Chunk_, and it then gets pushed into the `completedRegularChunks` property of the _Flight Request_. As that _Chunk_ is completed, there is no longer any reason to keep it in the `abortableTasks` set so it is removed. 

We'll come back to `emitModelChunk` and `attemptResolveElement` soon. For now, let's take a look at the `catch` block to see what happens when a _Task_ fails to resolve immediately. 

<RetryTaskCatch />

So, if the `model` cannot immediately be resolved into a React Element, we enter the `catch` block. First, we check to see if the `thrownValue` is a `SuspenseException` which is just [a special type of error that React uses to indicate that a component has suspended](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react-reconciler/src/ReactFiberThenable.js#L26). Either way, what we're looking for is a `then` method on the `thrownValue`. If it has one, we know that it is a _Thenable_ and we can use it to retry the task later.

So, this is where the `ping` method on the task comes into play. If the `thrownValue` is a _Thenable_, we can use its `then` method to retry the task later. Notice how `ping` is passed into the `then` method twice. This is because the `then` method takes two arguments-- one for the fulfilled case and one for the rejected case. However, we want to run the same function either way. So, we pass the `ping` method into both arguments. 

Next, we enter a series of code related to the new [postpone API](https://github.com/facebook/react/commit/ac1a16c67e268fcb2c52e91717cbc918c7c24446) from the most recent commit by the React team. This is related to the rendering of infinite promises. This was released less than a week ago, and I plan on devoting [the entire fourth chapter](./4-suspense-and-use) to the `use` hook, `Suspense`, and the lifecycle of a _Task_. So, we'll come back to this.

Finally, if the object being thrown doesn't contain a `then` method or the correct `$$typeof` property for the new _Postpone API_, then this must be some kind of error. First, we remove the task from the `abortableTasks` set and set its status to _ERRORED_. Then, we log the error while rendering an error _Chunk_ with the `emitErrorChunk` function.

It may seem a bit hard to put together everything that's happening up to this point, but that's because we skipped over the most important functions. Most of the serious work begins in `attemptResolveElement`. This initiates the serialization process leading up to `emitModelChunk` as we actually encode the data to prepare the stream.

## attemptResolveElement

Because this function is so large, I decided to break it up into individual sections. All of the code will be here. It will simply separated by purpose. For instance, if you were to copy and paste each section sequentially into another document, you would get the whole function. However, if you would like to simply view it in full, you can just [click here to go straight to the source code.](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react-server/src/ReactFlightServer.js#L443)

<AttemptResolveElement />

1. ### Beginning, Ref Check, and Prop/Children Storage -- [back to code](#attemptResolveElement_-_code)
This first part is rather simple, but I split it into its own portion for the sake of screen space. Let's start by talking about the arguments. Most of them are pretty similar to [the ones that React normally uses when creating an element](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react/src/ReactElement.js#L148). However, we also pass through the `thenableState`, and as usual, the whole `request`.

It begins with a quick indication of how this function can only be used to process _Server Components_. We start by making sure that there are no [`ref` objects](https://react.dev/reference/react/useRef) included in the element. These are usually used to [track some information](https://react.dev/learn/referencing-values-with-refs) or [manipulate the DOM](https://react.dev/learn/manipulating-the-dom-with-refs). However, these cannot be included anywhere within _RSC's_, so there is an early warning. 

Apparently, _React Elements_ will be changing in shape soon. I know I've seen them, but I can't find any more sources for this, though. I would love some help in [the comments](https://jessedit.tech/blog/react-server-components#comments).

Next, the `props` and `children` objects are logged to `weakMap` data structures. This is just [to help with some error handling](https://unpkg.com/browse/react-server-dom-webpack@0.0.0-experimental-b4cdd3e89-20230823/cjs/react-server-dom-webpack-server.browser.development.js#L1235) later if there are any issues during this entire process. After this, and for the remainder of the function, we will be checking the crucial `type` property to see how we should attempt to serialize the element.

2. ### Functional Components -- [back to code](#attemptResolveElement_-_code)
To start, we check to see if we working with a [`Client Component`](https://nextjs.org/docs/getting-started/react-essentials#client-components). I will be covering this in much more detail in [chapter five](./5-client-components). For now, all you need to know is this is just [checking the $$typeof property](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react-server-dom-webpack/src/ReactFlightWebpackReferences.js#L28) as usual.

From there, we see the most common initial serialization pattern employed by React in a _Flight Request_ for a React element. It's an array that starts with the _REACT_ELEMENT_TYPE_ symbol, followed by the `type`, `key`, and `props` respectively. This prepares the element for further processing. We'll see it a few more times in this function.

However, the vast majority of this section is devoted to resolving functional _Server Components_. First, [the `thenableState` is set.](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react-server/src/ReactFlightHooks.js#L35) Since we're on the `rootTask`, this is still null. Next, we get a `result` by running the functional component with its `props`.

Finally, we attempt to return a value any way that we can. We start by checking to see if the function returns a _Thenable_, and then we check if what that function returns can be resolved immediately. If we can return a value synchronously, we will. Otherwise, we are forced to use the [`createLazyWrapperAroundWakeable` function](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/react-server/src/ReactFlightServer.js#L399). We'll explore this more in [chapter four](./4-suspense-and-use).

3. ### Pure HTML, Symbols, and Fragments -- [back to code](#attemptResolveElement_-_code)

Another relatively simple section, but this could actually represent a good bulk of well-written code. First, we check to see if the component's `type` is just a string. That usually means that it's just a [normal HTML Element tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element).

When writing server components, there is really no limit to the amount of bare HTML you can use to build your app. As it is already an extremely lightweight representation of data, it can simply be sent over without further processing. We use the same preferred serialization data structure which is an array composed of the _REACT_ELEMENT_TYPE_ symbol and the `type`, `key`, and `props` properties.

Next, we check if the `type` is a symbol. The only thing we treat specially in this case are [React Fragments](https://react.dev/reference/react/Fragment). As they are only necessary for functional grouping of elements (especially in JSX), it is generally safe to disregard them entirely in favor of simply passing through their `children`. This is what React does here.

Every other `type` that is a symbol is then just passed into the normal array data structure as they could be a "built-in component". I assume this means [these four listed here](https://react.dev/reference/react/components), but I find this mildly surprising since there are so few. And, most of these are covered by parts of the process. I mean, we just covered fragments. But, I guess there's no harm in just sending the component over and letting the client figure it out.

4. ### Other React Objects and Error Handling -- [back to code](#attemptResolveElement_-_code)

From here, we do one more check of the `type` property. The only thing we will accept after this point will be objects that are not null. We begin with another check for [Client Components](https://react.dev/reference/react/use-client). The first check in section two was for functions that resolved in client components. This time, we're checking for client components that have already been processed into objects. If they are found here, they are converted into the now familiar array format.

After that, we enter a switch statement based on around the `$$typeof` property of the `type` object. Here, we check for four [special symbols](https://github.com/facebook/react/blob/b4cdd3e8922713f8c9817b004a0dc51be47bc5df/packages/shared/ReactSymbols.js). Although they kind of speak for themselves, I'll define them and briefly describe how they are handled.

    1. #### REACT_LAZY_TYPE
    DINGLE DONGLE

    2. #### REACT_FORWARD_REF_TYPE - DINGLE DONGLE

    3. #### REACT_MEMO_TYPE
        DINGLE DONGLE

    4. #### REACT_PROVIDER_TYPE
DINGLE DONGLE


## emitModelChunk

<EmitModelChunk />

For now, let's focus on the `toJSON` property on which the `resolveModelToJSON` function is attached.

## resolveModelToJSON

Okay, this is another big one! So, let's break this one up bit by bit again. This is a [JSON Replacer Function](https://dillionmegida.com/p/second-argument-in-json-stringify/) which is responsible for serializing the _model_ that is full of functions and rich data structures into something that can be streamed across the network boundary.

<ResolveModelToJSON />

1. ### Beginning and Initial Data Check -- [back to code](#resolveModelToJSON_-_code)
* hi
2. ### REACT_ELEMENT_TYPE -- [back to code](#resolveModelToJSON_-_code)
* hi
3. ### Other Important Objects -- [back to code](#resolveModelToJSON_-_code)
* hi
4. ### Exotic Data Structures -- [back to code](#resolveModelToJSON_-_code)
* hi
5. ### Functions -- [back to code](#resolveModelToJSON_-_code)
* hi
6. ### Symbol, BigInt, etc. -- [back to code](#resolveModelToJSON_-_code)
* hi

After doing some quick checks for unserializable client component props, the first thing in the actual work-loop is a check to see if the current value being serialized is a React Element. These all-capital signifiers are just a more conspicuous way of checking for the special symbols that React encodes into every element.

So, any time this replacer function encounters that specific Symbol, it replaces it with a single $ character. This is how React knows that it is a React Element that needs to be serialized. We'll be using the [RSC DevTools created by Alver Lagerlof](https://www.alvar.dev/blog/creating-devtools-for-react-server-components) to show you what this looks like in practice for our first demo. Here's what the React Element for our `App` component looks like in the DevTools after it has been serialized.

[![React Element](/rsc/RSC.png)](/rsc/RSC.png)

Next, we'll skip over some code related to server context so we can talk about this part.


Finally, let's take a look at the one function in `renderToReadableStream` that we haven't covered yet.

## startFlowing

So, up to this point, we have covered what happens in the `createRequest` and `startWork` functions. As we saw in the [renderToReadableStream](#rendertoreadablestream) function, `createRequest` will be called directly before the stream begins. Then, `startWork` is called once with the `start` method on the stream. However, there is one more function that is called every time the stream reader requests more data. This is the `pull` method in which the `startFlowing` function is used. Let's take a look at it.

<StartFlowing />

So now, hopefully all of the checks on the `destination` property up to this point make sense. When the request is first created, the `destination` property is `null`. So, the first time the `pull` method is called, the `destination` property is finally set. Then, the `flushCompletedChunks` function is actually run.

We're not going to get fully into how the stream is written as it is beyond the scope of this article. However, I do want to quickly step through the call stack as it has implications for how the _RSC Payload_ should be read. This block of code will be very long, so feel free to minimize it immediately if you want to skip to my summary.

<Stream />

So, this is how the _RSC Payload_ is actually written to the stream. At the very beginning of the `flushCompletedChunks` function, the `beginWriting` function is called. This function creates a new `Uint8Array` and sets its `VIEW_SIZE` to 512 bytes. Back in the [Chunks and Thenables](#chunks-and-thenables) section, I included 

There is a priority system in place to make sure that the most important chunks are written first. The `importsChunks` are written first. Because the modules are loaded asynchronously, we don't know how long this may take. And, most components rely on external modules. So, this comes first. Next, the `hintChunks` are written. These can 


## Conclusion

Hey
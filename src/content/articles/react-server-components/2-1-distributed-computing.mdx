---
title: "Distributed Computing"
nextLink: "./2-2-rpcs"
video: "zZiPJHg9wOY"
---

import ImageLink from "../../../components/ImageLink.astro"

import Youtube from "../../../components/Youtube.astro"


## Distributed Computing

It took us [four thousand years](https://en.wikipedia.org/wiki/Timeline_of_computing_hardware_before_1950) to get from [the abacus](https://www.youtube.com/watch?v=O5nskjZ_GoI) to the [first recognizable computers](https://www.youtube.com/watch?v=EcWsNdyl264) around World War II. The advanced mathematics required for missile defense and the paranoid atmosphere of the Cold War afterward provided the fertile ground necessary to accelerate this advancement. [Within forty years](https://arstechnica.com/information-technology/2019/10/50-years-ago-today-the-internet-was-born-sort-of/), computers could share files between Hawaii and London in mere moments. This might not seem like much now, but the journey to this point was not straightforward.

### The Beginning

[Alan Turing](https://en.wikipedia.org/wiki/Alan_Turing) first imagined how a 'computing machine' could [store a program in memory](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf) in 1936. It was only theoretical, but he used the word 'process' 33 times to explain how the machine could maintain an observable 'state of mind' based on its input which could be used to determine its future behavior. At that point, a [computer was still a job description for a human being](https://en.wikipedia.org/wiki/Computer_(occupation)). In 1937, [Claude Shannon](https://en.wikipedia.org/wiki/Claude_Shannon) proved how circuits and relays could be used to represent the boolean algebra created by [George Boole](https://en.wikipedia.org/wiki/George_Boole) almost a century before. 

[Boolean Algebra](https://en.wikipedia.org/wiki/Boolean_algebra) showed how actual problems could be solved with just two values and a few simple operators, and Shannon showed how to use existing technology to harness this logic. Within six years, the U.S. military began work on the [ENIAC](https://en.wikipedia.org/wiki/ENIAC) to help calculate ballistics trajectories. While the ENIAC was programmable, it still used the decimal system. Programming was a matter of [switches and wires](https://www.youtube.com/watch?v=AyxZsNq1nIA), and it initially required every aspect of the program to be completely rewired each time. Its successor, the [EDVAC](https://en.wikipedia.org/wiki/EDVAC), was one of the first computers to use binary to store programs in memory.

[John von Neumann](https://en.wikipedia.org/wiki/John_von_Neumann) was a famous mathematician, and he consulted on both projects. He released a paper about his work on the EDVAC where he explained how one could connect an input to an output through stored memory with the use of an [automatic computing system](https://web.archive.org/web/20130314123032/http://qss.stanford.edu/~godfrey/vonNeumann/vnedvac.pdf). This quickly became known as [Von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture), and it revolutionized computing. At that point, IBM dominated the industry, but it was not what we imagine today. 

The term ["super-computing"](https://en.wikipedia.org/wiki/Tabulating_machine) is sometimes said to have originated in reference to IBM’s [accounting machines](https://www.ibm.com/ibm/history/interactive/ibm_history.pdf). The company was built on a new technology for storing and transferring information, the ["punch card"](https://en.wikipedia.org/wiki/Card_punch). The Industrial Revolution both required and facilitated the processing of data, and IBM was one of the first companies to capitalize on this. They took electromechanical computing to its limits when they helped build the [Harvard Mark I](https://en.wikipedia.org/wiki/Harvard_Mark_I), but IBM could see the writing on the wall. Soon, their digital computing [mainframes](https://en.wikipedia.org/wiki/IBM_mainframe) dominated the industry.

<ImageLink 
src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg/1280px-Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg" 
alt="The ENIAC"
href="https://en.wikipedia.org/wiki/ENIAC" />

### The Problem

In the beginning, computers were [extremely expensive](https://www.youtube.com/watch?v=26QPDBe-NB8). These groundbreaking devices didn't just cost millions of dollars in today's money, but they also took up entire rooms and usually required multiple people to operate. Once they were generally available, it was very common for queues to form while programmers waited to use the computer. So people were given time limits, and these were often barely long enough to get their programs set up. [There was no operating system](https://www.cs.uni.edu/~fienup/courses/copy-of-operating-systems/lecture-notes/notes98f-1.lwp/odyframe.htm), so every program had to be built from scratch. 

Building on existing technology, programs were soon punched into paper cards at a desk separate from the computer. There's not much data that you can hold on a piece of paper, so decks of these cards would get processed at once as a single "task" or "job". To make matters worse, only one task could be processed at a time as the cards must be read in order, and you don't want to mix up different stacks. Not only did you have to load each program by hand, but one long job would *block* the entire queue.

As computer processing speed rapidly increased, it [quickly became apparent](https://web.archive.org/web/20170702215126/http://www.bobbemer.com/TIMESHAR.HTM) to a number of people that [the humans were the slowest part of this entire process](https://cs.gordon.edu/courses/cs322/lectures/history.html). Every moment that the computer sat idle was a waste of money, and it was [somebody's job to schedule and process each task](http://www.cap-lore.com/Software/TS.html). Soon, it was discovered that you could use magnetic tape to hold the programs in memory. Before long, they started finding ways to [process multiple jobs at once](https://en.wikipedia.org/wiki/Batch_processing).

This made things even more frustrating for the programmers because even [small jobs could take forever](https://bitsavers.org/pdf/mit/whirlwind/summer_session_1954/Digital_Computers_Advanced_Coding_Techniques_Summer_1954.pdf). You might [wait 24 hours](https://archive.org/details/time-sharing-at-mit/mode/2up?view=theater) just to find out that your program had a bug in it. This was the most primitive form of [time-sharing](https://en.wikipedia.org/wiki/Time-sharing), but this term grew to refer to a wide umbrella of answers to this problem. Some of these solutions evolved into what was originally called [multiprogramming](https://www.andrew.cmu.edu/course/15-412/ln/412springlecture1.html).

<ImageLink 
src="http://images.computerhistory.org/revonline/images/500003057-03-01.jpg?w=600" 
alt="'Programmer standing beside punched cards', 1955. Each punch card can only hold about 80 bytes so this is probably around 5MB of data."
href="https://www.computerhistory.org/revolution/memory-storage/8/326/924" />

## Multiprogramming

In the 1950's, computer processing and memory progressed rapidly as people discovered different ways of storing, processing, and transferring digital information. [Two key advancements](http://www.cap-lore.com/Hardware/int.html) that went hand in hand were [hardware interrupts](https://people.computing.clemson.edu/~mark/interrupts.html) and [virtual memory](https://ethw.org/Milestones:Atlas_Computer_and_the_Invention_of_Virtual_Memory,_1957-1962). Now, computers could hold multiple programs in memory at once and even switch between them. [Atlas Supervisor](http://www.chilton-computing.org.uk/acl/technology/atlas/p019.htm) is often called the first operating system, as it was the first program built to coordinate multiple other programs using these tools.

The hardest part of building an operating system is managing multiple processes while keeping things responsive for the user and maintaining the integrity of the data. Interrupts allow the computer to respond to external events in the middle of a program with the use of a predetermined [interrupt handler](https://student.cs.uwaterloo.ca/~cs350/W19/notes/threads-1up.pdf), and it's also extremely useful for [handling exceptions like dividing by zero](http://www.cap-lore.com/Hardware/int.html) so that the entire machine doesn't crash. The operating system also needs to be able to store the state of each program in memory as it quickly switches between them. This is called [context switching](https://en.wikipedia.org/wiki/Context_switch), and it's basically impossible to do without virtual memory.

Before long, others were working on similar concepts. This method of time-sharing was developed by [Christopher Strachey](https://en.wikipedia.org/wiki/Christopher_Strachey), and he mentioned it in passing to a gentleman named [J.C.R. Licklider](https://en.wikipedia.org/wiki/J._C._R._Licklider). Licklider soon envisioned a [Man-Computer Symbiosis](https://en.wikipedia.org/wiki/Man-Computer_Symbiosis) with human cognition aided by networks of computers.

Licklider worked at a company called [BBN](https://en.wikipedia.org/wiki/Raytheon_BBN), and he convinced the leadership to build the [BBN time-sharing system](https://en.wikipedia.org/wiki/BBN_Time-Sharing_System). He had worked at MIT previously, and he got help from a few of his former coworkers like [John McCarthy](https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)). Licklider was an effective evangelist of networked computers, and the _US_ government was quick to notice. In 1962, he was appointed head of the Information Processing Techniques Offices of the Advanced Research Projects Agency-- soon to be known as [DARPA](https://en.wikipedia.org/wiki/DARPA#History).

<Youtube
    videoID="UYb6WqWBTE0"
    title="Before Unix: An Early History of Timesharing Systems"
/>

### Project MAC

Licklider was convinced that computer networking was the future, so he started distributing grants around the country for things like the innovative [Project Genie](https://web.archive.org/web/20110719144454/http://coe.berkeley.edu/news-center/publications/forefront/archive/forefront-fall-2007/features/berkeley2019s-piece-of-the-computer-revolution) time-sharing system at _UC_ Berkeley. John McCarthy had been [advocating for time-sharing](https://web.stanford.edu/~learnest/jmc/timesharing-memo.pdf) at MIT, and they had implemented the [Compatible Time-Sharing System](https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System) in 1961. After Licklider organized a $2 million dollar grant from _ARPA_, [the group at MIT](http://larch-www.lcs.mit.edu:8001/~corbato/sjcc62/) were able to make a few more innovations in what came to be known as [Project MAC](https://multicians.org/project-mac.html).

The most influential thing to come out of Project MAC was undoubtedly something called [Multics](https://en.wikipedia.org/wiki/Multics). This [innovative operating system](https://www.youtube.com/watch?v=Q07PhW5sCEk) was designed to combine open access with security, and it explored many new ways of sharing computer processing and memory. It [gave each user their own their own address space](http://dl.acm.org/citation.cfm?id=1463915) inside of its [virtual memory](https://www.multicians.org/multics-vm.html) as well as access to a few common procedures. Beyond that, Multics was [filled with groundbreaking features](https://www.multicians.org/features.html) like a [shell between the user and the operating system](https://www.multicians.org/shell.html) to make it easier to use.

The main goal of the program was for each user to [feel like they had their own computer](http://jmc.stanford.edu/computing-science/timesharing.html). To achieve this, MIT built a system of terminals that each had a [flexowriter](https://en.wikipedia.org/wiki/Friden_Flexowriter) so that multiple people could interact with the mainframe at once. The most innovative touch of all was the [process scheduling](https://apps.dtic.mil/sti/pdfs/ADA223897.pdf) program that decided which jobs to run based on priority. This central traffic controller could even allow [inter-process communication](https://web.mit.edu/Saltzer/www/publications/MIT-MAC-TR-030.ocr.pdf). Each user had their own stack of tasks defined within its own unique process, and Multics even had a [primitive version of email](https://www.multicians.org/thvv/mail-history.html).

Licklider made great strides in his two years at _ARPA_, and others were beginning to see the potential for networked computers. By 1963, he was already imagining what he was calling an [Intergalactic Computer Network](https://en.wikipedia.org/wiki/Intergalactic_Computer_Network). We'll see how this progressed in a moment, but I want to take a quick aside to talk about programming languages. One of Licklider's biggest issues while planning this network was the [vast number of compilers](https://www.thekurzweillibrary.com/memorandum-for-members-and-affiliates-of-the-intergalactic-computer-network) in use at the time.

## Programmers

As time-sharing systems became prominent, people were quickly discovering how challenging it could be to coordinate multiple processes on the same computer. Even though they were rapidly becoming more powerful, one intense computation could hold up the entire system. Even worse, it was hard to share memory between processes without them corrupting each other. Project MAC was rapidly innovating on the ground, but it was not immediately influential. 

Before we go any further, I want to clarify a few terms. A computer program is the list of instructions given to the computer to complete a task. [A process is the current execution state of a program](https://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=thread). The execution state or [program state](https://www.google.com/books/edition/A_Discipline_of_Multiprogramming/eZtxLnc3NbYC?hl=en&gbpv=1&bsq=%22Program+state%22+variables&pg=PA14&printsec=frontcover) is the [value of all variables at any given point](https://www.google.com/books/edition/C_Primer_Plus/MYWQbufdVU4C?hl=en&gbpv=1&bsq=%22Program+state%22+variables&pg=PT113&printsec=frontcover) of program execution. A variable is just a value stored in memory and referenced by a [memory address](https://en.wikipedia.org/wiki/Memory_address). 

To complete a _context switch_, the operating system must store both the program state and the memory address of the next instruction to be executed in virtual memory. This [process control block](https://en.wikipedia.org/wiki/Process_control_block) allows the operating system to rapidly switch between processes in the middle of program execution. In the beginning, every program was _single-threaded_ with only one [locus of execution](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=a6d65b599a58eada963d8d2acf4e205046142df6) as people were still learning how to control these giant, expensive computers. In fact, the word _thread_ was actually [used as a synonym for _process_](https://web.mit.edu/Saltzer/www/publications/MIT-MAC-TR-030.ocr.pdf) in one of the Multics papers.

It would take some time for all of these concepts to fully coalesce because 'programming' was nothing more than connecting a room full of wires together at first. I've been using the word programmer for convenience, but that was not truly distinguished as a profession until around this point. While [Ada Lovelace](https://en.wikipedia.org/wiki/Ada_Lovelace) pioneered the field, most of the people using computers were mathematicians and scientists. They just needed to make difficult calculations, and it wasn't their job to worry about optimizing the computing process.

Much of the reason this changed was due to the U.S. Military's response to World War II. As they ordered more and more gigantic contracts like the [SAGE missile defense system](https://en.wikipedia.org/wiki/Semi-Automatic_Ground_Environment) from IBM, the need for specialists started to become clear. The ENIAC was built to calculate artillery firing tables, and some of the human computers that were hired to assist with it became the first programmers. 

<ImageLink 
src="https://upload.wikimedia.org/wikipedia/commons/b/b7/Ada_Byron_daguerreotype_by_Antoine_Claudet_1843_or_1850_-_cropped.png" 
alt="Ada Lovelace"
href="https://en.wikipedia.org/wiki/Ada_Lovelace" />

### "Compilers"

[Kathleen Antonelli](https://en.wikipedia.org/wiki/Kathleen_Antonelli#Computer_programmer) worked on the ENIAC, and she helped invent [the subroutine](https://en.wikipedia.org/wiki/Function_(computer_programming)) which was a way to get a computer to repeat parts of the program multiple times. A subroutine is a general term for a reusable block of code, and sometimes these would be called [procedures](https://cs.stackexchange.com/questions/154623/what-is-a-procedure). At this point in history, you can just think of it as [a function that changes global state but returns void](http://www.edwardbosworth.com/CPSC2105/Lectures/Slides_06/Chapter_08/SubroutineLinkage.pdf).

I will also give credit to the programmers who worked on the [EDSAC](https://en.wikipedia.org/wiki/EDSAC) which followed soon afterwards as they pioneered concepts such as [Assembly language](https://en.wikipedia.org/wiki/Assembly_language). Some of the key people involved got together and wrote the first real programming book, [The Preparation of Programs for an Electronic Digital Computer](https://archive.org/details/programsforelect00wilk/page/24/mode/2up?view=theater). Although [Turing had written about similar concepts](https://www.npl.co.uk/getattachment/about-us/History/Famous-faces/Alan-Turing/turing-proposal-Alan-LR.pdf?lang=en-GB), they were the first ones to write down how to put these ideas into practice. D.J. Wheeler was one of these engineers, and he first defined [a 'library' of subroutines](http://www.laputan.org/pub/papers/wheeler.pdf?source=techstories.org) in 1952.

The company that built the ENIAC later hired [Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper). Generally, a compiler is a computer program that transforms what you write into something the computer can understand. Each assembly language is highly specific to the computer architecture for which it was built. So, compilers were designed to [make programs reusable](https://en.wikipedia.org/wiki/History_of_compiler_construction) between computers.

[Grace Hopper](https://president.yale.edu/biography-grace-murray-hopper) built A-0 which was called a compiler, but it really just gave programmers access to some [common subroutines](https://dl.acm.org/doi/pdf/10.1145/800025.1198341) that made their life easier. She was already working on something called [B-0](https://en.wikipedia.org/wiki/FLOW-MATIC) which would allow programs to be written in plain english. This would later inspire [COBOL](https://en.wikipedia.org/wiki/COBOL), but she was beaten to the punch by IBM.

<ImageLink 
src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Commodore_Grace_M._Hopper%2C_USN_%28covered%29.jpg/800px-Commodore_Grace_M._Hopper%2C_USN_%28covered%29.jpg" 
alt="Grace Hopper"
href="https://en.wikipedia.org/wiki/Grace_Hopper" />

### Early Languages

The closest thing to a modern programming language came with [FORTRAN](https://en.wikipedia.org/wiki/Fortran) in 1957 which was built by [John Backus](https://en.wikipedia.org/wiki/John_Backus) simply because IBM wanted to [lower the costs associated with computing](https://www.softwarepreservation.org/projects/FORTRAN/paper/p25-backus.pdf). Although a language called [Plankalkül](https://en.wikipedia.org/wiki/Plankalk%C3%BCl) was conceptualized in the 1940's, it was stifled by the fall of Nazi Germany. FORTRAN was proprietary to IBM and [not very expressive](https://cyber.dabamos.de/programming/fortran/transcompiler/lecture01.pdf), so a committee was formed to create a common programming language that computer scientists could share while researching new paradigms. Backus advised this committee, and [they designed ALGOL](https://en.wikipedia.org/wiki/ALGOL) in 1958. They called it IAL at first, and [Backus later said](https://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf) this about their intentions:

> The Zurich ACM-GAMM Conference had two principal motives in proposing the IAL: (a) To provide a means of communicating numerical methods and other procedures between people, and (b) To provide a means of realizing a stated process on a variety of machines...

This was the first language to fully incorporate [Lambda Calculus](https://en.wikipedia.org/wiki/Lambda_calculus). They knew the field was changing rapidly, so they decided to iterate on new versions while distinguishing them by the year they were designed. ALGOL 58 introduced the concept of code blocks which was further refined in ALGOL 60 with new features like lexical scope facilitated by a *call stack*. This allows variables to be enclosed within a function and automatically removed from memory when the function is done.

ALGOL 60 introduced the concept of a [thunk](https://en.wikipedia.org/wiki/Thunk) which is a way to [store a function in memory](https://dl.acm.org/doi/pdf/10.1145/366062.366084) so that it is not immediately evaluated. A language called [Simula](https://en.wikipedia.org/wiki/Simula) was built on top of ALGOL 60, and Simula 67 was notably influential. Simula was intended to complete complex simulations by [modelling discrete events within the system](https://web.archive.org/web/20040826234002/https://www.idi.ntnu.no/grupper/su/publ/simula/holmevik-simula-ieeeannals94.pdf), and it introduced exciting new ideas like [objects and classes](https://web.archive.org/web/20131225084408/http://www.edelweb.fr/Simula/scb-1.pdf). 

John McCarthy from MIT advised on ALGOL 60 after he had built his own language called [Lisp](http://www.paulgraham.com/icad.html) in 1958. Lisp pioneered recursion, first-class functions and [conditional expressions](https://www.nlp-kyle.com/post/understanding_lisp/). Less than fifteen years after the subroutine was first conceived, Lisp was experimenting with [dynamic scope](https://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf) by [passing functions to other functions](https://www.softwarepreservation.org/projects/LISP/MIT/AIM-004.pdf) so that variable values depend on the current state of the call stack. Lisp had a minimal working interpreter by 1960 which was joined by [a full compiler with garbage collection by 1962](https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf). To clarify, garbage collection is just the removal of data that is no longer needed from memory so that those memory addresses can be reused. 

While FORTRAN was widely used due to IBM's stranglehold on the computing world at the time, ALGOL was [immensely influential](https://web.eecs.umich.edu/~bchandra/courses/papers/Hoare_Hints.pdf). This new ability to express computer programs in text was crucial. Computer programming was at the forefront of mathematics, and even luddites could now join the fray. As time-sharing systems like Project MAC and Project Genie started to be implemented across the world, the need to [share this single processor in the most efficient manner](https://i.unu.edu/media/unu.edu/publication/1562/report325.pdf) grew increasingly important.

<ImageLink 
src="https://i0.wp.com/javaconceptoftheday.com/wp-content/uploads/2019/07/TimelineOfProgrammingLanguages.png?ssl=1" 
alt="Programming Language Timeline"
width="800"
href="https://javaconceptoftheday.com/history-of-programming-languages/" />

## Early Concurrency

[Edsger W. Dijkstra barely used computers personally](https://web.archive.org/web/20031210213835/http://www.utexas.edu/faculty/council/2002-2003/memorials/Dijkstra/dijkstra.html), but he helped build the first ALGOL 60 compiler. Later, he worked on an incredibly innovative operating system called [THE multiprogramming system](https://en.wikipedia.org/wiki/THE_multiprogramming_system). Much of our current thoughts on concurrent programming can be tracked to Dijkstra's 1965 paper [Cooperating Sequential Processes](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html) where he defined a *bounded buffer* as a storage area of finite size to hold data temporarily. 

His concepts of [semaphores, mutual exclusion](https://dl.acm.org/doi/epdf/10.1145/363095.363143), and self-stabilizing [finite state machines](https://dl.acm.org/doi/pdf/10.1145/361179.361202) were extremely influential. Soon, people were discovering the power of combining bounded buffers and semaphores with a [First-In-First-Out (FIFO) queue system](https://dl.acm.org/doi/pdf/10.1145/360051.360079) to coordinate provider-consumer relationships in an attempt to mitigate the perils of [race conditions](https://en.wikipedia.org/wiki/Race_condition) and [deadlocks](https://en.wikipedia.org/wiki/Deadlock). [Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare) built on these primitives with something called a [Monitor](https://dl.acm.org/doi/pdf/10.1145/355620.361161) which helped solve many of the issues caused by multiple users of a single computer sharing resources.

[Semaphores are a kind of signal](https://computationstructures.org/lectures/synchronization/synchronization.html#20) that live in a common memory location between processes. They determine when each process can access shared resources to ensure that these only get used by one process at a time. This mutual exclusion allows **synchronization**, and this helps prevent data corruption. In the same way that you didn't want to mix up people's punch cards when doing batch processing, you also don't want multiple processes accessing shared values from memory at the same time. So, you need to **block** access to this [critical section](https://en.wikipedia.org/wiki/Critical_section) until each process is done.

Dijkstra was extremely prolific, and he published articles on numerous topics including [garbage collection](https://lamport.azurewebsites.net/pubs/garbage.pdf) which is especially difficult when juggling multiple processes. By 1978, Tony Hoare refined his ideas on concurrency into something called [Communicating Sequential Processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes) which incorporated [message passing](https://en.wikipedia.org/wiki/Message_passing). Message passing can take many forms from functional to object-oriented depending on who you ask, but it's generally defined as a way of encapsulating behavior within the communication between processes.

### The Actor Model, SmallTalk, and Scheme

[Carl Hewitt](https://en.wikipedia.org/wiki/Carl_Hewitt) was also greatly [influenced by Dijkstra](https://professorhewitt.blogspot.com/2021/03/further-development-of-dijkstras.html), but he took his own path when developing the [Actor Model](https://en.wikipedia.org/wiki/Actor_model) in 1973. Hewitt believed that [Dijkstra's model was too reliant on global state](https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf), so he proposed an alternative that was completely based around asynchronous message passing. Hewitt defined Actors as "computational entities" that can independently send and receive messages from other Actors to which they are connected, and these messages can change their behavior or even create new Actors. 

Hewitt had been [inspired by Simula 67 and Lisp](https://www.ijcai.org/Proceedings/73/Papers/027B.pdf), but he also thanked someone named [Alan Kay](https://en.wikipedia.org/wiki/Alan_Kay) in his first paper on the Actor model. Alan Kay had been working on a language called [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk) which was also extremely innovative. Kay rejected conventional thought by saying, "why [would anyone] want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to?" By Smalltalk-72, the core concept was that [everything was an object](http://gagne.homedns.org/~tgagne/earlyhistoryst.html). He adopted the phrase [Object-Oriented Programming](https://www.youtube.com/watch?v=oKg1hTOQXoY&t=3262s), but Kay would later regret this label.

Instead, he would often insist that ["the big idea is Messaging"](https://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html), and that "the mental image was one of separate computers sending requests to other computers that had to be accepted and understood by the receivers before anything could happen." [Dan Ingalls](https://dl.acm.org/doi/pdf/10.1145/3386335) built [one of the first virtual machines](https://stackoverflow.com/questions/25079085/which-programming-language-was-first-to-use-virtual-machine) to bring Kay's ideas to life. It started out as a fairly simple interpreter, but this would grow quite complicated by 1980. Smalltalk never achieved much mainstream success, but it was extremely influential.

In 1972, while Hewitt was still formulating the Actor model, [Gerald Sussman](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman) and [Guy Steele](https://en.wikipedia.org/wiki/Guy_L._Steele_Jr.) decided to make a small version of Actors in Lisp to better understand the concept. They were students at MIT where Hewitt was a researcher, and all three of them were involved with Project MAC. Sussman and Steele were [impressed by what they built](https://web.archive.org/web/20060615225746/http://www.brics.dk/~hosc/local/HOSC-11-4-pp399-404.pdf) as they thought "all the patterns of control structure that Hewitt had described in terms of actors could equally well be described by the lambda calculus". 

This became [Scheme](https://www.scheme.org/) which many consider to be [the most influential version of Lisp](https://tratt.net/laurie/research/pubs/html/tratt__dynamically_typed_languages/), and it [popularized concepts](https://research.scheme.org/lambda-papers/) like [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)) and [continuations](https://en.wikipedia.org/wiki/Continuation). Lisp was so popular in the burgeoning AI community that they even made [special machines](https://en.wikipedia.org/wiki/Lisp_machine) to run it more efficiently, but it is known to be overwhelming to beginners. Scheme's simplicity made it a great teaching language. While it will play a major role later in our story, Scheme did not see wide usage outside of academic circles. [Hewitt was critical of Scheme](https://dspace.mit.edu/handle/1721.1/6272) as its "hairy control structure" did not achieve the full concurrency he desired.

<Youtube
    videoID="oKg1hTOQXoY"
    title="Alan Kay at OOPSLA 1997 - The Computer Revolution Hasn't Happened Yet"
/>

### Concurrent Pascal

In fact, a paper released in 1978 said that [high-level language support for concurrency was largely non-existant](https://www.cs.cmu.edu/~bryant/pubdir/MIT-CSG-148-2.pdf), but they did take some time to talk about [Concurrent Pascal](https://en.wikipedia.org/wiki/Concurrent_Pascal) by [Per Brinch Hansen](https://en.wikipedia.org/wiki/Per_Brinch_Hansen). [Pascal](https://en.wikipedia.org/wiki/Pascal_(programming_language)) is notable for being the first typesafe language, and it's yet another variant of ALGOL 60. Like many others, Per Brinch Hansen had been greatly influenced by Dijkstra. Brinch Hansen, Hoare, and Dijkstra were all [working together at the same time](https://link.springer.com/article/10.1007/s11023-023-09632-2), and they are generally considered to be the fathers of concurrent programming. 

In 1969, Brinch Hansen built an operating system for something called the [RC4000 multiprogramming system](https://en.wikipedia.org/wiki/RC_4000_multiprogramming_system). Instead of only serving a single purpose, RC4000 was the first small operating system that was designed to be flexible. Its greatest innovation was ensuring a [special protected area of memory called the kernel](https://en.wikipedia.org/wiki/Kernel_(operating_system)) which formalized some of the concepts seen in Multics. Most operating systems today build on this concept. 

Brinch Hansen later built Concurrent Pascal which uses [multiple processes coordinated by a monitor using a disk buffer](http://brinch-hansen.net/papers/1975a.pdf). One issue was that the programmer always had to remember to imperatively call `continue` as the initial statement was usually intended to execute forever. Still, synchronization of processes within a single computer had never been so easy. In fact, there was [no memory protection whatsoever](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=969effe7509150634b2c9cd74157bb6804a8d438).

Later, he refined this idea into the concept of distributed processes that could be used in [real-time programs running across networks of microcomputers](https://dl.acm.org/doi/pdf/10.1145/359642.359651). Key to this concept was the ability for "processes to call common procedures defined within other processes" while maintaining no common variables. This is vaguely similar to a [Remote Procedure Call](https://en.wikipedia.org/wiki/Remote_procedure_call) which was being conceived elsewhere at the same time. Concurrent Pascal was radically innovative, and [Brinch Hansen's work was influential](https://dl.acm.org/doi/pdf/10.1145/361454.361473). I suppose I should explain what I mean by microcomputers.

## Microcomputers

Computing was still advancing at a remarkable pace. [IBM remained the dominant force](https://spectrum.ieee.org/building-the-system360-mainframe-nearly-destroyed-ibm), and their ubiquity allowed them to set the standard for the industry as a whole. Each mainframe was still completely unique which made upgrading these expensive machines painful. 

So, IBM announced an operating system called [System/360](https://en.wikipedia.org/wiki/IBM_System/360) in 1964 that was designed to be compatible with a wide variety of hardware, and it brought a lot of innovation into the mainstream. By 1972, System/360 offered a way for the user to [manually split up work within a program](https://bitsavers.org/pdf/ibm/360/os/R21.0_Mar72/GC28-6534-3_OS360_Introduction_R21_Jan72.pdf). They called these 'subtasks', and they used the word [time slicing](http://www.bitsavers.org/pdf/ibm/360/os/R21.0_Mar72/GC28-6720-4_MVT_Guide_Release_21_Mar72.pdf) to explain how they rapidly switched between them.

[Integrated circuits](https://en.wikipedia.org/wiki/Integrated_circuit) became generally available around this time, and a young company called Intel released the [first microprocessor in 1971](https://en.wikipedia.org/wiki/Intel_4004). [Minicomputers](https://www.nytimes.com/1970/04/05/archives/maxi-computers-face-mini-conflict-mini-trend-reaching-computers.html) quickly became popular, but don't get too confused. These things were still [usually around the size of a refrigerator](https://en.wikipedia.org/wiki/Minicomputer) at first. Still, computing was becoming more generally available than ever before as the necessary parts continued to grow smaller and cheaper. Soon, a variety of competitors emerged to tap into this new market.

The word minicomputer was mostly an advertising term, so it was no surprise when people started marketing things as [microcomputers](https://en.wikipedia.org/wiki/Micral) shorty after that. It was a natural extension from [the word microprocesser](https://computerhistory.org/blog/who-invented-the-microprocessor/). By 1973, [the first personal computer was released](https://en.wikipedia.org/wiki/Altair_8800), and it was quickly followed by the [Apple I](https://en.wikipedia.org/wiki/Apple_I) in 1976. It was clear that a sea change had been completed when IBM released the [Personal Computer](https://en.wikipedia.org/wiki/IBM_Personal_Computer) in 1981, and a different type of operating system was needed to take advantage of these new capabilities.

<Youtube
    videoID="FxZ_Z-_j71I"
    title="First Apple Commercial 1977 by High Technology, Inc."
/>

### IBM, CP/M, and Microsoft

A man named [Gary Kildall](https://en.wikipedia.org/wiki/Gary_Kildall) began experimenting with Intel's new microprocessors, and he soon wrote the first operating system for them called [CP/M](https://en.wikipedia.org/wiki/CP/M)-- Control Program for Microcomputers. By today's standards, it's just a simple single-user shell, but he pioneered the creation of something called a [BIOS](https://gsmall.us/Computing/CPM/Archive/CPM-History-GaryKildall-DrDobsJournal-20071104.pdf). This stands for Basic Input/Output System, and it's a way to abstract away the hardware so that the operating system could be easily ported to different machines. Combined with its relatively cheap price, CP/M quickly became [the standard operating system for microcomputers](https://books.google.com/books?id=Mj0EAAAAMBAJ&pg=PA10#v=onepage&q&f=false).

Kildall also wrote a language for microprocessors called [PL/M](https://en.wikipedia.org/wiki/PL/M), but versions of [BASIC](https://en.wikipedia.org/wiki/BASIC) were much more popular. As you might guess from the name, BASIC is very simple as it was originally designed to be a teaching language, but it was quickly adopted by hobbyists like a couple young men named [Bill Gates](https://en.wikipedia.org/wiki/Bill_Gates) and [Paul Allen](https://en.wikipedia.org/wiki/Paul_Allen). Gates and Allen built some BASIC interpreters for various microcomputer companies like Apple and Altair as the first product of their new company, [Microsoft](https://en.wikipedia.org/wiki/Microsoft)-- a combination of the words microcomputer and software. 

Microsoft's only other major project until 1981 was a card that helped [run CP/M on Apple computers](https://archive.org/details/1980-05-compute-magazine/page/n7/mode/2up?view=theater), but they established themselves as the programming language authority in the personal computing world. So, when IBM decided to wade into the PC market, they turned to Microsoft for not just BASIC, but also [FORTRAN and COBOL](https://www.pcmag.com/news/the-rise-of-dos-how-microsoft-got-the-ibm-pc-os-contract) as well. Beyond the languages, IBM needed an operating system. CP/M was the obvious answer, so Gates suggested that IBM should talk to Kildall.

For whatever reason, Kildall's company rejected working with IBM, so [Microsoft gladly stepped in](https://www.youtube.com/watch?v=_cMtZFwqPHc&list=PLAXA1ccaOnGdbStEwcKE56YzlYDYOx2Tx&index=3). Microsoft [bought a competitor](https://en.wikipedia.org/wiki/86-DOS) with a compatible interface, and this soon became MS-DOS. Although Kildall and Gates were friends, [Gates was extremely competitive](https://www.youtube.com/watch?v=bLVbSjDq0DE). Suddenly, all the software that had been written for CP/M could be used in the new IBM PC, and Microsoft was off to the races as MS-DOS became their flagship product. Before that point, the only operating system they had ever built was actually [a version of Unix](https://en.wikipedia.org/wiki/Xenix).

### Unix

The Multics operating system was developed at Project MAC as a joint venture with General Electric and Bell Labs. The [folks at Bell Labs](https://www.multicians.org/unix.html) dropped out of the project in 1969 as they felt like it was moving too slowly. Four of their best engineers had been [inspired by Multics](https://www.bell-labs.com/usr/dmr/www/hist.pdf), and they wanted to implement some of its ideas on a smaller scale. They later said they wanted to make computing as simple as possible while building ["a system around which a community could form"](https://www.youtube.com/watch?v=XvDZLjaCJuw). Using a PDP-7 minicomputer, [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson) began the work that same year.

[Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie) started helping out, and he began [designing the language](https://www.bell-labs.com/usr/dmr/www/chist.pdf) that would become [known as C](https://en.wikipedia.org/wiki/C_(programming_language)). C is technically a distant relative of ALGOL-60, but it went through [many iterations in between](https://en.wikipedia.org/wiki/CPL_(programming_language)) which made it [virtually unrecognizable](https://www.bell-labs.com/usr/dmr/www/kbman.pdf). C found a utilitarian middleground between expressiveness and power, and it gave developers powerful tools like [dynamic memory allocation](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation) while still being relatively easy to use. Before long, they re-wrote Unix using C. This proved how Ritchie and Thompson were guided by the philosophy of creating tools that would make it easy to build larger tools. 

They wanted Unix to be interactive, so they borrowed some ideas from Multics like a shell that starts a new process for each command and a file system that is organized into nested directories. However, unlike the supercomputers at MIT, Unix was intended to run on minicomputers with limited power. While it was much more minimal by design, they gave programmers the power to fix most issues. 

They admitted there was ["no general inter-process communication or synchronization scheme"](https://www.bell-labs.com/usr/dmr/www/retro.pdf), but they did introduce something called [a signal](https://en.wikipedia.org/wiki/Signal_(IPC)). A signal is a [system call](https://en.wikipedia.org/wiki/System_call), and it's a bit like the software equivalent of a hardware interrupt. The most important of these was [fork](https://en.wikipedia.org/wiki/Fork_(system_call)) which allows the developer to create a child process inside a program. The Unix team knew that people could use these primitives to implement things like semaphores from scratch, but they suggested just using a file in that paper. 

[Other people](https://www.cs.dartmouth.edu/~doug/reader.pdf) from Bell Labs started helping out as well. By 1975, [pcc](https://dl.acm.org/doi/pdf/10.1145/512760.512771) was developed which was a [Portable Compiler](https://web.archive.org/web/20060912181946/http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-149.pdf) designed to make it easy to implement C on any machine. After this point, Unix grew in popularity as it became well-known for being [compact and adaptable](https://archive.org/details/byte-magazine-1983-10/page/n267/mode/2up?view=theater). Like all other software at the time, this was [completely proprietary](https://en.wikipedia.org/wiki/Research_Unix) to Bell Labs until it [spread all the way across the country to Berkeley in 1974](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution). 

<Youtube
    videoID="XvDZLjaCJuw"
    title="UNIX: Making Computers Easier To Use -- AT&T Archives film from 1982, Bell Laboratories"
/>

### Pipes and Sockets

Bell had a monopoly on communications. This gave them a huge budget for Bell Labs, but it also [landed them in legal trouble](https://en.wikipedia.org/wiki/Breakup_of_the_Bell_System) numerous times. By the time Unix was being created, Bell was forbidden to compete commercially. Because of this, [the license to use Unix was remarkably cheap](https://archive.org/details/byte-magazine-1983-10/page/n133/mode/2up?view=theater) compared to something like System/360. Soon, the source code was generally available, and a [multitude of variants](https://archive.org/details/byte-magazine-1983-08/page/n215/mode/2up?view=theater) were created thanks to Unix's unique mixture of ["reasonable efficiency and expressive power"](https://www.cs.utexas.edu/users/dahlin/Classes/GradOS/papers/p365-ritchie.pdf).

Unix quickly became popular in both academic and corporate settings, and it was the [preferred operating system of computing enthusiasts](https://wiki.tuhs.org/lib/exe/fetch.php?media=publications:qcu.pdf). It was used in a wide variety of devices by the 1980s, but it was particularly suited for networking. Unix had a [simple form of email](https://en.wikipedia.org/wiki/Mail_(Unix)) from the very beginning, and more features were added over time that made it easier to communicate between processes.

A member of the team named [Doug McIlroy](https://en.wikipedia.org/wiki/Douglas_McIlroy) was inspired by the ["data streams"](http://www.columbia.edu/~rh120/ch106.x09) that were made possible by another recent innovation-- [coroutines](https://en.wikipedia.org/wiki/Coroutine). A coroutine is basically just a [function that can be temporarily suspended with its state intact](https://softpanorama.org/Scripting/Piporama/history.shtml) which allows multiple parts of a program to work together. [Pipes](https://en.wikipedia.org/wiki/Pipeline_(Unix)) were seen as [a way of connecting programs](https://web.archive.org/web/20131213024204/http://www.princeton.edu/~hos/Mahoney/expotape.htm) together like [connecting pieces of a garden hose](https://www.youtube.com/watch?v=bKzonnwoR2I) to gradually output data.

In 1979, [UUCP](https://en.wikipedia.org/wiki/UUCP) was created so that Unix machines could communicate through phone lines. By the very next year, people were talking to each other from across the country on [Usenet](https://en.wikipedia.org/wiki/Usenet) which was originally called the [“Unix Users Network”](https://www.ais.org/~jrh/acn/ACn35-3.pdf). This was only the beginning. Eventually, the Berkeley version of Unix became the first operating system to [incorporate TCP/IP](https://www.oreilly.com/library/view/open-sources/1565925823/ch04.html) and [sockets](https://people.computing.clemson.edu/~jmarty/courses/commonCourseContent/AdvancedModule-OSConceptsAndApplicationToLinux/UnixIPC-NamesPipesCh9Text.pdf) after [Bill Joy](https://en.wikipedia.org/wiki/Bill_Joy) implemented an early version of the specification. Unix was so popular that it was used and loved by [many of the contractors who built the ARPANET](https://www.salon.com/2000/05/16/chapter_2_part_one/), but I'm getting ahead of myself--let's backtrack just a bit.